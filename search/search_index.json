{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the training sessions overview This is a (non-exhaustive) list of training sessions given by Geert Jan Bex , either offered on a regular basis by the Vlaams Supercomputing Centrum (VSC) and EuroCC@Belgium, or on demand by research institutes, governmental agencies and companies. All of these training sessions can be tailored to the audience if required, and ad-hoc training sessions are possible as well. For many sessions, a dedicated website has been created that provides detailed information, as well as a link to a GitHub repository that hosts the material specific for that training. For those sessions that do not yet have their own dedicated website, the material can be found in the training-materials repository: https://github.com/gjbex/training-material Many of the training sessions are organized in collaboration with the Vlaams Supercomputer Centrum (VSC) and EuroCC@Belgium . You can find the schedule of upcoming training sessions on their website. For EuroCC training sessions, please consult the EuroCC training portal on EuroCC ACCESS. Below is a list of all the training sessions that are currently available. A graphical overview of the training sessions on computational skills is available. Training sessions C++ C++ is an important language for scientific programming and HPC. C++ for scientific programming (14 hours) This training focuses on using C++ for scientific programming and on the way Bjarne Stroustrup advocates modern C++ in his book \"A tour of C++\". Some C++17, C++20 and C++23 features and third party libraries will also be discussed. For detailed information, see: https://gjbex.github.io/Scientific-C-plus-plus/ C++ software engineering This training focuses on building applications and libraries in a professional way using best practices in software engineering. For detailed information, see: https://gjbex.github.io/C-plus-plus-software-engineering/ Parallel programming with the STL and Threading Building Blocks (3 hours) Out of the box, the STL contains many algorithms that can be run in parallel. In this training, you will learn how to do that, and what the performance benefits may be. Threading Building Blocks (TBB) is a C++ template library for developing shared memory applications. It integrates well with the C++ Standard Template Library (STL) and can be used with any modern C++ compiler. TBB is especially suited for nested parallelism, and pipe-lining when part of the application can use accelerator hardware. Subjects: STL parallel algorithms Threading Building Blocks programming and execution model recap of required C++ features algorithms: parallel_for , parallel_reduce , parallel_do task based programming data-flow programming, task graphs pitfalls and best practices Prerequisites: experience in C++ programming Other training sessions useful for C++ programmers Parallel programming with OpenMP Parallel programming with MPI OpenMP GPU offloading Heterogeneous programming with Kokkos Code optimization Defensive programming and debugging Best practices in scientific programming Version control with git Fortran programming Fortran for programmers (8 hours) Fortran is used a lot in the context of HPC. For many, it has a reputation of being an old and ugly programming language. However, modern Fortran is a far cry from Fortran 77 that its detractors have in mind. Fortran 2003/2008 is a language that is well tailored towards scientific computing. This training introduces the language and its features. For detailed information, see: https://gjbex.github.io/Fortran-for-programmers/ Other training sessions useful for Fortran programmers Parallel programming with OpenMP Parallel programming with MPI OpenMP GPU offloading Code optimization Defensive programming and debugging Best practices in scientific programming Version control with git C programming C is still a very popular programming language, also in the context of scientific programming and HPC. Scientific C (12 hours) C is still one of the more popular programming languages today. It is probably mainly used for systems programming, but there are also many applications for scientific computing that have been developed in this programming language. For detailed information, see: https://gjbex.github.io/Scientific-C/ Other training sessions useful for C programmers Parallel programming with OpenMP Parallel programming with MPI OpenMP GPU offloading Code optimization Defensive programming and debugging Best practices in scientific programming Version control with git Python training sessions Python is a versatile programming language that is used in many domains. Python for beginners (16 hours) Python is a versatile programming language that is used in many domains. It is easy to learn. This training material introduces the basics, and can be used for self-study, or as a basis for training sessions. It requires no prior programming experience. For detailed information, see: https://gjbex.github.io/Python-for-beginners/ Python for programmers (4 hours) Python is an all-round programming language that has applications in many domains. This training session introduces the programming language to participants who have programming experience with other programming languages such as R, MATLAB, C/C++ or Fortran. For detailed information, see: https://gjbex.github.io/Python-for-programmers/ Python software engineering (4 hours) Quality of software matters, whether you share it with others or not. Software should be easy to install, easy to use, and well documented. This training will cover those aspects from the perspective of the Python ecosystem. However, it is also important that software is easy to maintain, so coding style matters, API-level documentation should be available, as well as a battery of tests to ensure the software's integrity. Of course, good design is at least as important. For detailed information, see: https://gjbex.github.io/Python-software-engineering/ Scientific Python (4 hours) Python is a nice programming language for scientific programming. Many high quality libraries are available as building block in a wide variety of scientific domains. In this training we will concentrate on the core libraries, and give some examples of domain specific libraries. For detailed information, see: https://gjbex.github.io/Scientific-Python/ Python for data science (4 hours) Python is one of the dominant languages in data science. In this training we will cover a number of modules that are useful for data preparation, analyzing data, visualization, and machine learning. For detailed information, see: https://gjbex.github.io/Python-for-data-science/ Machine learning with Python (4 hours) Python is one of the dominant languages in the area of machine learning and AI. This training will provide an introduction to machine learning methodology for data preparation and machine learning, as well as some machine learning algorithms. For detailed information, see: https://gjbex.github.io/Machine-learning-with-Python/ Python for HPC (8 hours) Although vanilla Python is fairly slow and hence not a good candidate, there are several options to significantly increase the efficiency of Python programs. For detailed information, see: https://gjbex.github.io/Python-for-HPC/ Python on GPUs (4 hours) Python is more and more used for scientific computing and can be used to develop code that runs on GPGPUs. Additionally, a number of libraries that are commonly used in scientific computing, data science and machine learning can use GPGPUs to improve performance. For detailed information, see: https://gjbex.github.io/Python-on-GPUs/ Python dashboards (2 hours) Dashboards are a useful way to present data in an interactive way. They can be used for reporting, but also for data exploration, or even to create simple web applications. You can run dashboards locally, or deploy them via GitHub or GitLab, or even on a server in the cloud. Creating dashboards in Python is quite straightforward. In this training you will learn about several frameworks and their strengths and weaknesses. For detailed information, see: https://gjbex.github.io/Python-dashboards/ Python systems programming (4 hours) Python is a very versatile programming language that has a wide range of applications. This training concentrates on interaction with the operating system, the file system, other applications and the network. This is useful for systems programming, but also when you want to use Python as a coordination language for your workflows. This training introduces modules that are useful in that context. For detailed information, see: https://gjbex.github.io/Python-for-systems-programming/ Other training sessions useful for Python programmers Parallel programming with MPI Best practices in scientific programming Version control with git Jupyter notebooks Julia: the good, the bad and the ugly (4 hours) Julia has gained quite some traction over the last couple of years, but is it for you? In this training you will see how it compares to MATLAB and Python, and what Julia's strong and weak points are. For detailed information, see: https://gjbex.github.io/Julia_good_bad_ugly/ Jupyter notebooks (3 hours) Jupyter notebooks are a versatile tools for data exploration and exploratory programming in a wide variety of programming languages. In this session you will learn how to use Jupyter Notebooks effectively. For details on Jupyter notebooks, see: https://gjbex.github.io/Jupyter-notebooks/ Parallel programming These courses have been developed by Rolf Rabenseifner (HLRS, Stuttgart, Germany) and the training has followed Rolf's train-the-trainer program. Parallel programming with MPI (14 hours) MPI (Message Passing Interface) is the de-facto standard for distributed parallel programming of scientific applications. It specifies language bindings for C and Fortran. This training covers the MPI 3.1 standard, but also emphasizes potential pitfalls and best practices. Subjects: process model and language bindings messages and point-to-point communication non-blocking communication collective communication groups, communicators and virtual topologies one-sided communication shared memory derived data types parallel I/O best practices Prerequisites: experience in C, C++, Fortran or Python programming; for the section on hybrid programming, notions of OpenMP are required. Parallel programming with OpenMP (7 hours) OpenMP provides a very convenient programming model for scientific applications that run multiple threads. It is supported by C, C++ and Fortran compilers. Its main advantage is that it is mostly used through annotation of code, which makes it easy to pick low hanging fruit when starting to parallelize code. The training covers OpenMP 4.5, and emphasizes pitfalls and best practices. Subjects: programming and execution model worksharing directives data environment tasking SIMD constructs thread placement pitfalls and best practices Prerequisites: experience in C, C++, or Fortran. OpenMP GPU offloading (4 hours) GPUs are used more and more in scientific computing, data science and machine learning. This training will introduce you to using hardware-agnostic programming using OpenMP to offload computations to GPUs. For detailed information, see: https://gjbex.github.io/GPU-programming/ Heterogeneous programming with Kokkos (8 hours) Kokkos is a C++ library that enables writing performance portable code for heterogeneous systems. It can offload to accelerators such as GPUs. For detailed information, see: https://gjbex.github.io/GPU-programming/ Defensive programming and debugging (4 hours + 2 hours optional) All code contains bugs, finding and fixing them is boring. In this training, best practices are presented to reduce the number of bugs in your code. You will also learn about debuggers and debugging techniques to find bugs more efficiently. For detailed information, see: https://gjbex.github.io/Defensive-programming-and-debugging/ Supplementary material: Online reading material Code optimization (4 hours) For HPC applications, performance is a major concern. A thorough understanding of the relevant hardware and software components is required. In this training, you will learn about a number of these components, and how they influence the efficiency of you application. You will also learn how to profile your application to identify performance bottlenecks. For detailed information, see: https://gjbex.github.io/Code-optimization/ Best practices for scientific computing (4 hours) As a scientist, your core business is science, not software engineering. Nevertheless, having a good understanding of how best practices in software engineering can help you work more efficiently, or give your work more exposure is quite useful. This training is flexible in that it can be tailored to any combination of C, C++, Fortran or Python, and to many levels of detail. Subjects: code style version control & collaboration testing unit testing functional testing code coverage documentation deployment continuous integration Prerequisites: fluency in at least one programming language Supplementary material: website Linux bash shell (4 hours) In HPC, most interaction with the systems is through the terminal and a shell. Working efficiently in such an environment saves a lot of time and frustration. In this training, you will learn the basics of bash, as well as some Linux OS concepts. Subjects: interacting with files and directories editors: nano, and hints at more sophisticated editors process management sharing: file and directory permissions searching: find and grep compressed files and archives: tar, gzip copying to/from remote systems: scp, sftp, rclone Prerequisites: none HPC introduction (3 hours) Although working on High Performance Computing (HPC) infrastructures is not rocket science, there are still a number of things you need to be aware of to do so efficiently. Note that this session is specific for (potential) users of the infrastructure managed by the Vlaams Supercomputing Centrum (VSC). Subjects: how to access the systems architecture of a cluster shared file systems software stack resource manager and scheduler accounting Prerequisites: familiarity with the Linux command line Best practices for data science on HPC (4 hours) Although it seems that running data science workflows on HPC systems is quite straightforward, there are quite a number of pitfalls and best practices that you need to be aware of. Subjects: how to fine-tune your data science workflow for HPC data formats and I/O distributed computing Prerequisites: familiarity with the Linux command line familiarity with the basics of HPC systems familiarity with R or Python Container for HPC (4 hours) Singularity can be viewed as the Docker for HPC, i.e., a Singularity image contains all the operating system/software components for your application and can be deployed and run on HPC infrastructure, as well as on your own laptop. For detailed information, see: https://gjbex.github.io/Containers-for-HPC/ Workflows for HPC (4 hours) The HPC ecosystems provides numerous tools to help you manage your workflows. In this training, you will learn about some of these tools, and how to use them effectively. For detailed information, see: https://gjbex.github.io/Workflows-for-HPC/ MLOps on HPC (4 hours) MLOps is a set of practices that aims to deploy and maintain machine learning models reproducibly, reliably and efficiently. In this training you will learn how to use MLOps tools on HPC systems. In fact, this training is also for you if you perform any kind of computational experiments, not just machine learning. For detailed information, see: https://gjbex.github.io/MLOps-on-HPC/ Version control with git (4 hours) Version control is an essential part of the software development process and is crucial for scientific application to help reproducibility. You will learn how to use a version control system (either git or SVN) to document the changes in your source code. For detailed information, see: https://gjbex.github.io/Version-control-with-git/ Generative AI for software engineering and data analysis (3 hours) Generative AI is a useful tool in software engineering and data analysis. However, if you want to use it effectively, you need to understand the basics of the underlying technology, and to be aware of potential pitfalls.. After an introduction to the basics of generative AI, various applications will be demoed, and you will be able to experiment with some of them yourself. Tools such as OpenAI's Chat-GPT and GitHub's Copilot will be discussed. Prerequisites: experience in some programming language; familiarity with the Linux command line Deploying LLMs locally (4 hours) Large/Small Language Models are very useful tools in software engineering and data analysis. However, if you want to use them effectively, you need to understand the basics of the underlying technology, and to be aware of potential pitfalls. In many situations it is useful to deploy a LLM locally, rather than using a cloud service. This training will show you how to do that. For detailed information, see: https://gjbex.github.io/Deploying-LLMs-locally/ Scientific visualization with ParaView (2 hours) ParaView is an open-source, multi-platform data analysis and visualization tools for scientific data. In this training you will learn how to use ParaView to visualize your data. Prerequisites: none Code of conduct Please note that by participating in any training listed here, either online, hybrid, or face-to-face you implicitly agree to adhere to the code of conduct . License All the training materials are licensed under the Creative Commons Attribution 4.0 International License .","title":"Introduction"},{"location":"#welcome-to-the-training-sessions-overview","text":"This is a (non-exhaustive) list of training sessions given by Geert Jan Bex , either offered on a regular basis by the Vlaams Supercomputing Centrum (VSC) and EuroCC@Belgium, or on demand by research institutes, governmental agencies and companies. All of these training sessions can be tailored to the audience if required, and ad-hoc training sessions are possible as well. For many sessions, a dedicated website has been created that provides detailed information, as well as a link to a GitHub repository that hosts the material specific for that training. For those sessions that do not yet have their own dedicated website, the material can be found in the training-materials repository: https://github.com/gjbex/training-material Many of the training sessions are organized in collaboration with the Vlaams Supercomputer Centrum (VSC) and EuroCC@Belgium . You can find the schedule of upcoming training sessions on their website. For EuroCC training sessions, please consult the EuroCC training portal on EuroCC ACCESS. Below is a list of all the training sessions that are currently available. A graphical overview of the training sessions on computational skills is available.","title":"Welcome to the training sessions overview"},{"location":"#training-sessions","text":"","title":"Training sessions"},{"location":"#c","text":"C++ is an important language for scientific programming and HPC.","title":"C++"},{"location":"#c-for-scientific-programming-14-hours","text":"This training focuses on using C++ for scientific programming and on the way Bjarne Stroustrup advocates modern C++ in his book \"A tour of C++\". Some C++17, C++20 and C++23 features and third party libraries will also be discussed. For detailed information, see: https://gjbex.github.io/Scientific-C-plus-plus/","title":"C++ for scientific programming (14 hours)"},{"location":"#c-software-engineering","text":"This training focuses on building applications and libraries in a professional way using best practices in software engineering. For detailed information, see: https://gjbex.github.io/C-plus-plus-software-engineering/","title":"C++ software engineering"},{"location":"#parallel-programming-with-the-stl-and-threading-building-blocks-3-hours","text":"Out of the box, the STL contains many algorithms that can be run in parallel. In this training, you will learn how to do that, and what the performance benefits may be. Threading Building Blocks (TBB) is a C++ template library for developing shared memory applications. It integrates well with the C++ Standard Template Library (STL) and can be used with any modern C++ compiler. TBB is especially suited for nested parallelism, and pipe-lining when part of the application can use accelerator hardware. Subjects: STL parallel algorithms Threading Building Blocks programming and execution model recap of required C++ features algorithms: parallel_for , parallel_reduce , parallel_do task based programming data-flow programming, task graphs pitfalls and best practices Prerequisites: experience in C++ programming","title":"Parallel programming with the STL and Threading Building Blocks (3 hours)"},{"location":"#other-training-sessions-useful-for-c-programmers","text":"Parallel programming with OpenMP Parallel programming with MPI OpenMP GPU offloading Heterogeneous programming with Kokkos Code optimization Defensive programming and debugging Best practices in scientific programming Version control with git","title":"Other training sessions useful for C++ programmers"},{"location":"#fortran-programming","text":"","title":"Fortran programming"},{"location":"#fortran-for-programmers-8-hours","text":"Fortran is used a lot in the context of HPC. For many, it has a reputation of being an old and ugly programming language. However, modern Fortran is a far cry from Fortran 77 that its detractors have in mind. Fortran 2003/2008 is a language that is well tailored towards scientific computing. This training introduces the language and its features. For detailed information, see: https://gjbex.github.io/Fortran-for-programmers/","title":"Fortran for programmers (8 hours)"},{"location":"#other-training-sessions-useful-for-fortran-programmers","text":"Parallel programming with OpenMP Parallel programming with MPI OpenMP GPU offloading Code optimization Defensive programming and debugging Best practices in scientific programming Version control with git","title":"Other training sessions useful for Fortran programmers"},{"location":"#c-programming","text":"C is still a very popular programming language, also in the context of scientific programming and HPC.","title":"C programming"},{"location":"#scientific-c-12-hours","text":"C is still one of the more popular programming languages today. It is probably mainly used for systems programming, but there are also many applications for scientific computing that have been developed in this programming language. For detailed information, see: https://gjbex.github.io/Scientific-C/","title":"Scientific C (12 hours)"},{"location":"#other-training-sessions-useful-for-c-programmers_1","text":"Parallel programming with OpenMP Parallel programming with MPI OpenMP GPU offloading Code optimization Defensive programming and debugging Best practices in scientific programming Version control with git","title":"Other training sessions useful for C programmers"},{"location":"#python-training-sessions","text":"Python is a versatile programming language that is used in many domains.","title":"Python training sessions"},{"location":"#python-for-beginners-16-hours","text":"Python is a versatile programming language that is used in many domains. It is easy to learn. This training material introduces the basics, and can be used for self-study, or as a basis for training sessions. It requires no prior programming experience. For detailed information, see: https://gjbex.github.io/Python-for-beginners/","title":"Python for beginners (16 hours)"},{"location":"#python-for-programmers-4-hours","text":"Python is an all-round programming language that has applications in many domains. This training session introduces the programming language to participants who have programming experience with other programming languages such as R, MATLAB, C/C++ or Fortran. For detailed information, see: https://gjbex.github.io/Python-for-programmers/","title":"Python for programmers (4 hours)"},{"location":"#python-software-engineering-4-hours","text":"Quality of software matters, whether you share it with others or not. Software should be easy to install, easy to use, and well documented. This training will cover those aspects from the perspective of the Python ecosystem. However, it is also important that software is easy to maintain, so coding style matters, API-level documentation should be available, as well as a battery of tests to ensure the software's integrity. Of course, good design is at least as important. For detailed information, see: https://gjbex.github.io/Python-software-engineering/","title":"Python software engineering (4 hours)"},{"location":"#scientific-python-4-hours","text":"Python is a nice programming language for scientific programming. Many high quality libraries are available as building block in a wide variety of scientific domains. In this training we will concentrate on the core libraries, and give some examples of domain specific libraries. For detailed information, see: https://gjbex.github.io/Scientific-Python/","title":"Scientific Python (4 hours)"},{"location":"#python-for-data-science-4-hours","text":"Python is one of the dominant languages in data science. In this training we will cover a number of modules that are useful for data preparation, analyzing data, visualization, and machine learning. For detailed information, see: https://gjbex.github.io/Python-for-data-science/","title":"Python for data science (4 hours)"},{"location":"#machine-learning-with-python-4-hours","text":"Python is one of the dominant languages in the area of machine learning and AI. This training will provide an introduction to machine learning methodology for data preparation and machine learning, as well as some machine learning algorithms. For detailed information, see: https://gjbex.github.io/Machine-learning-with-Python/","title":"Machine learning with Python (4 hours)"},{"location":"#python-for-hpc-8-hours","text":"Although vanilla Python is fairly slow and hence not a good candidate, there are several options to significantly increase the efficiency of Python programs. For detailed information, see: https://gjbex.github.io/Python-for-HPC/","title":"Python for HPC (8 hours)"},{"location":"#python-on-gpus-4-hours","text":"Python is more and more used for scientific computing and can be used to develop code that runs on GPGPUs. Additionally, a number of libraries that are commonly used in scientific computing, data science and machine learning can use GPGPUs to improve performance. For detailed information, see: https://gjbex.github.io/Python-on-GPUs/","title":"Python on GPUs (4 hours)"},{"location":"#python-dashboards-2-hours","text":"Dashboards are a useful way to present data in an interactive way. They can be used for reporting, but also for data exploration, or even to create simple web applications. You can run dashboards locally, or deploy them via GitHub or GitLab, or even on a server in the cloud. Creating dashboards in Python is quite straightforward. In this training you will learn about several frameworks and their strengths and weaknesses. For detailed information, see: https://gjbex.github.io/Python-dashboards/","title":"Python dashboards (2 hours)"},{"location":"#python-systems-programming-4-hours","text":"Python is a very versatile programming language that has a wide range of applications. This training concentrates on interaction with the operating system, the file system, other applications and the network. This is useful for systems programming, but also when you want to use Python as a coordination language for your workflows. This training introduces modules that are useful in that context. For detailed information, see: https://gjbex.github.io/Python-for-systems-programming/","title":"Python systems programming (4 hours)"},{"location":"#other-training-sessions-useful-for-python-programmers","text":"Parallel programming with MPI Best practices in scientific programming Version control with git Jupyter notebooks","title":"Other training sessions useful for Python programmers"},{"location":"#julia-the-good-the-bad-and-the-ugly-4-hours","text":"Julia has gained quite some traction over the last couple of years, but is it for you? In this training you will see how it compares to MATLAB and Python, and what Julia's strong and weak points are. For detailed information, see: https://gjbex.github.io/Julia_good_bad_ugly/","title":"Julia: the good, the bad and the ugly (4 hours)"},{"location":"#jupyter-notebooks-3-hours","text":"Jupyter notebooks are a versatile tools for data exploration and exploratory programming in a wide variety of programming languages. In this session you will learn how to use Jupyter Notebooks effectively. For details on Jupyter notebooks, see: https://gjbex.github.io/Jupyter-notebooks/","title":"Jupyter notebooks (3 hours)"},{"location":"#parallel-programming","text":"These courses have been developed by Rolf Rabenseifner (HLRS, Stuttgart, Germany) and the training has followed Rolf's train-the-trainer program.","title":"Parallel programming"},{"location":"#parallel-programming-with-mpi-14-hours","text":"MPI (Message Passing Interface) is the de-facto standard for distributed parallel programming of scientific applications. It specifies language bindings for C and Fortran. This training covers the MPI 3.1 standard, but also emphasizes potential pitfalls and best practices. Subjects: process model and language bindings messages and point-to-point communication non-blocking communication collective communication groups, communicators and virtual topologies one-sided communication shared memory derived data types parallel I/O best practices Prerequisites: experience in C, C++, Fortran or Python programming; for the section on hybrid programming, notions of OpenMP are required.","title":"Parallel programming with MPI (14 hours)"},{"location":"#parallel-programming-with-openmp-7-hours","text":"OpenMP provides a very convenient programming model for scientific applications that run multiple threads. It is supported by C, C++ and Fortran compilers. Its main advantage is that it is mostly used through annotation of code, which makes it easy to pick low hanging fruit when starting to parallelize code. The training covers OpenMP 4.5, and emphasizes pitfalls and best practices. Subjects: programming and execution model worksharing directives data environment tasking SIMD constructs thread placement pitfalls and best practices Prerequisites: experience in C, C++, or Fortran.","title":"Parallel programming with OpenMP (7 hours)"},{"location":"#openmp-gpu-offloading-4-hours","text":"GPUs are used more and more in scientific computing, data science and machine learning. This training will introduce you to using hardware-agnostic programming using OpenMP to offload computations to GPUs. For detailed information, see: https://gjbex.github.io/GPU-programming/","title":"OpenMP GPU offloading (4 hours)"},{"location":"#heterogeneous-programming-with-kokkos-8-hours","text":"Kokkos is a C++ library that enables writing performance portable code for heterogeneous systems. It can offload to accelerators such as GPUs. For detailed information, see: https://gjbex.github.io/GPU-programming/","title":"Heterogeneous programming with Kokkos (8 hours)"},{"location":"#defensive-programming-and-debugging-4-hours-2-hours-optional","text":"All code contains bugs, finding and fixing them is boring. In this training, best practices are presented to reduce the number of bugs in your code. You will also learn about debuggers and debugging techniques to find bugs more efficiently. For detailed information, see: https://gjbex.github.io/Defensive-programming-and-debugging/ Supplementary material: Online reading material","title":"Defensive programming and debugging (4 hours + 2 hours optional)"},{"location":"#code-optimization-4-hours","text":"For HPC applications, performance is a major concern. A thorough understanding of the relevant hardware and software components is required. In this training, you will learn about a number of these components, and how they influence the efficiency of you application. You will also learn how to profile your application to identify performance bottlenecks. For detailed information, see: https://gjbex.github.io/Code-optimization/","title":"Code optimization (4 hours)"},{"location":"#best-practices-for-scientific-computing-4-hours","text":"As a scientist, your core business is science, not software engineering. Nevertheless, having a good understanding of how best practices in software engineering can help you work more efficiently, or give your work more exposure is quite useful. This training is flexible in that it can be tailored to any combination of C, C++, Fortran or Python, and to many levels of detail. Subjects: code style version control & collaboration testing unit testing functional testing code coverage documentation deployment continuous integration Prerequisites: fluency in at least one programming language Supplementary material: website","title":"Best practices for scientific computing (4 hours)"},{"location":"#linux-bash-shell-4-hours","text":"In HPC, most interaction with the systems is through the terminal and a shell. Working efficiently in such an environment saves a lot of time and frustration. In this training, you will learn the basics of bash, as well as some Linux OS concepts. Subjects: interacting with files and directories editors: nano, and hints at more sophisticated editors process management sharing: file and directory permissions searching: find and grep compressed files and archives: tar, gzip copying to/from remote systems: scp, sftp, rclone Prerequisites: none","title":"Linux bash shell (4 hours)"},{"location":"#hpc-introduction-3-hours","text":"Although working on High Performance Computing (HPC) infrastructures is not rocket science, there are still a number of things you need to be aware of to do so efficiently. Note that this session is specific for (potential) users of the infrastructure managed by the Vlaams Supercomputing Centrum (VSC). Subjects: how to access the systems architecture of a cluster shared file systems software stack resource manager and scheduler accounting Prerequisites: familiarity with the Linux command line","title":"HPC introduction (3 hours)"},{"location":"#best-practices-for-data-science-on-hpc-4-hours","text":"Although it seems that running data science workflows on HPC systems is quite straightforward, there are quite a number of pitfalls and best practices that you need to be aware of. Subjects: how to fine-tune your data science workflow for HPC data formats and I/O distributed computing Prerequisites: familiarity with the Linux command line familiarity with the basics of HPC systems familiarity with R or Python","title":"Best practices for data science on HPC (4 hours)"},{"location":"#container-for-hpc-4-hours","text":"Singularity can be viewed as the Docker for HPC, i.e., a Singularity image contains all the operating system/software components for your application and can be deployed and run on HPC infrastructure, as well as on your own laptop. For detailed information, see: https://gjbex.github.io/Containers-for-HPC/","title":"Container for HPC (4 hours)"},{"location":"#workflows-for-hpc-4-hours","text":"The HPC ecosystems provides numerous tools to help you manage your workflows. In this training, you will learn about some of these tools, and how to use them effectively. For detailed information, see: https://gjbex.github.io/Workflows-for-HPC/","title":"Workflows for HPC (4 hours)"},{"location":"#mlops-on-hpc-4-hours","text":"MLOps is a set of practices that aims to deploy and maintain machine learning models reproducibly, reliably and efficiently. In this training you will learn how to use MLOps tools on HPC systems. In fact, this training is also for you if you perform any kind of computational experiments, not just machine learning. For detailed information, see: https://gjbex.github.io/MLOps-on-HPC/","title":"MLOps on HPC (4 hours)"},{"location":"#version-control-with-git-4-hours","text":"Version control is an essential part of the software development process and is crucial for scientific application to help reproducibility. You will learn how to use a version control system (either git or SVN) to document the changes in your source code. For detailed information, see: https://gjbex.github.io/Version-control-with-git/","title":"Version control with git (4 hours)"},{"location":"#generative-ai-for-software-engineering-and-data-analysis-3-hours","text":"Generative AI is a useful tool in software engineering and data analysis. However, if you want to use it effectively, you need to understand the basics of the underlying technology, and to be aware of potential pitfalls.. After an introduction to the basics of generative AI, various applications will be demoed, and you will be able to experiment with some of them yourself. Tools such as OpenAI's Chat-GPT and GitHub's Copilot will be discussed. Prerequisites: experience in some programming language; familiarity with the Linux command line","title":"Generative AI for software engineering and data analysis (3 hours)"},{"location":"#deploying-llms-locally-4-hours","text":"Large/Small Language Models are very useful tools in software engineering and data analysis. However, if you want to use them effectively, you need to understand the basics of the underlying technology, and to be aware of potential pitfalls. In many situations it is useful to deploy a LLM locally, rather than using a cloud service. This training will show you how to do that. For detailed information, see: https://gjbex.github.io/Deploying-LLMs-locally/","title":"Deploying LLMs locally (4 hours)"},{"location":"#scientific-visualization-with-paraview-2-hours","text":"ParaView is an open-source, multi-platform data analysis and visualization tools for scientific data. In this training you will learn how to use ParaView to visualize your data. Prerequisites: none","title":"Scientific visualization with ParaView (2 hours)"},{"location":"#code-of-conduct","text":"Please note that by participating in any training listed here, either online, hybrid, or face-to-face you implicitly agree to adhere to the code of conduct .","title":"Code of conduct"},{"location":"#license","text":"All the training materials are licensed under the Creative Commons Attribution 4.0 International License .","title":"License"},{"location":"ai_and_machine_learning/","text":"AI and machine learning AI and machine learning are increasingly used in many scientific domains. These trainings will help you learn how to use this in your own work. graph LR Machine_learning_with_Python[Machine learning with Python] --> Deploying_LLMs_locally[Deploying LLMs locally] Generative_AI_for_software_engineering_and_data_analysis[Generative AI for software engineering and data analysis] click Machine_learning_with_Python \"https://gjbex.github.io/Machine-learning-with-Python/\" \"Machine learning with Python\" click Deploying_LLMs_locally \"https://gjbex.github.io/Deploying-LLMs-locally/\" \"Deploying LLMs locally\" click Generative_AI_in_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI in software engineering and data analysis\"","title":"AI and machine learning"},{"location":"ai_and_machine_learning/#ai-and-machine-learning","text":"AI and machine learning are increasingly used in many scientific domains. These trainings will help you learn how to use this in your own work. graph LR Machine_learning_with_Python[Machine learning with Python] --> Deploying_LLMs_locally[Deploying LLMs locally] Generative_AI_for_software_engineering_and_data_analysis[Generative AI for software engineering and data analysis] click Machine_learning_with_Python \"https://gjbex.github.io/Machine-learning-with-Python/\" \"Machine learning with Python\" click Deploying_LLMs_locally \"https://gjbex.github.io/Deploying-LLMs-locally/\" \"Deploying LLMs locally\" click Generative_AI_in_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI in software engineering and data analysis\"","title":"AI and machine learning"},{"location":"best_practices_for_scientific_computing/","text":"Best practices for scientific computing As a scientist, your core business is science, not software engineering. Nevertheless, having a good understanding of how best practices in software engineering can help you work more efficiently, or give your work more exposure is quite useful. This training is flexible in that it can be tailored to any combination of C, C++, Fortran or Python, and to many levels of detail. Subjects: code style version control & collaboration testing unit testing functional testing code coverage documentation deployment continuous integration Prerequisites: fluency in at least one programming language Supplementary material: website","title":"Best practices for scientific computing"},{"location":"best_practices_for_scientific_computing/#best-practices-for-scientific-computing","text":"As a scientist, your core business is science, not software engineering. Nevertheless, having a good understanding of how best practices in software engineering can help you work more efficiently, or give your work more exposure is quite useful. This training is flexible in that it can be tailored to any combination of C, C++, Fortran or Python, and to many levels of detail. Subjects: code style version control & collaboration testing unit testing functional testing code coverage documentation deployment continuous integration Prerequisites: fluency in at least one programming language Supplementary material: website","title":"Best practices for scientific computing"},{"location":"c/","text":"C programming C is still a very popular programming language, also in the context of scientific programming and HPC. graph TD Scientific_C[Scientific C] --> Defensive_programming_and_debugging[Defensive programming and debugging] Scientific_C --> Code_optimization[Code optimization] Defensive_programming_and_debugging --> Code_optimization Code_optimization --> Parallel_programming_with_OpenMP[Parallel programming with OpenMP] Code_optimization[Code optimization] --> Parallel_programming_with_MPI[Parallel programming with MPI] Parallel_programming_with_OpenMP --> Parallel_programming_with_MPI Code_optimization --> GPU_programming[GPU programming] Parallel_programming_with_OpenMP --> GPU_programming click Scientific_C \"https://gjbex.github.io/Scientific-C/\" \"Scientific C\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_programming_with_OpenMP \"https://gjbex.github.io/Training-sessions/parallel_programming_with_openmp\" \"Parallel programming with OpenMP\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click GPU_programming \"https://gjbex.github.io/GPU-programming/\" \"GPU programming\"","title":"C"},{"location":"c/#c-programming","text":"C is still a very popular programming language, also in the context of scientific programming and HPC. graph TD Scientific_C[Scientific C] --> Defensive_programming_and_debugging[Defensive programming and debugging] Scientific_C --> Code_optimization[Code optimization] Defensive_programming_and_debugging --> Code_optimization Code_optimization --> Parallel_programming_with_OpenMP[Parallel programming with OpenMP] Code_optimization[Code optimization] --> Parallel_programming_with_MPI[Parallel programming with MPI] Parallel_programming_with_OpenMP --> Parallel_programming_with_MPI Code_optimization --> GPU_programming[GPU programming] Parallel_programming_with_OpenMP --> GPU_programming click Scientific_C \"https://gjbex.github.io/Scientific-C/\" \"Scientific C\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_programming_with_OpenMP \"https://gjbex.github.io/Training-sessions/parallel_programming_with_openmp\" \"Parallel programming with OpenMP\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click GPU_programming \"https://gjbex.github.io/GPU-programming/\" \"GPU programming\"","title":"C programming"},{"location":"code_of_conduct/","text":"Code of conduct This workshop is dedicated to providing a welcoming and supportive environment for all people, regardless of background or identity. By participating in this workshop, participants accept to abide by this Code of Conduct and accept the procedures by which any Code of Conduct incidents are resolved. We do not tolerate behavior that is disrespectful or that excludes, intimidates, or causes discomfort to others. We do not tolerate discrimination or harassment based on characteristics that include, but are not limited to, gender identity and expression, sexual orientation, disability, physical appearance, body size, citizenship, nationality, ethnic or social origin, pregnancy, familial status, veteran status, genetic information, religion or belief (or lack thereof), membership of a national minority, property, age, education, socio-economic status, technical choices, and experience level. Everyone who participates in workshop activities is required to conform to this Code of Conduct. It applies to all spaces managed by or affiliated with the workshop, including, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. Workshop hosts are expected to assist with the enforcement of the Code of Conduct. By participating, participants indicate their acceptance of the procedures by which the workshop resolves any Code of Conduct incidents, which may include storage and processing of their personal information. Expected behavior All participants in our events and communications are expected to show respect and courtesy to others. All interactions should be professional regardless of platform: either online or in-person. In order to foster a positive and professional learning environment we encourage the following kinds of behaviors in all workshop events and platforms: Use welcoming and inclusive language Be respectful of different viewpoints and experiences Gracefully accept constructive criticism Focus on what is best for the community Show courtesy and respect towards other community members Unacceptable behavior Examples of unacceptable behavior by participants at any workshop event/platform include: written or verbal comments which have the effect of excluding people on the basis of membership of any specific group causing someone to fear for their safety, such as through stalking, following, or intimidation violent threats or language directed against another person the display of sexual or violent images unwelcome sexual attention nonconsensual or unwelcome physical contact sustained disruption of talks, events or communications insults or put downs sexist, racist, homophobic, transphobic, ableist, or exclusionary jokes excessive swearing incitement to violence, suicide, or self-harm continuing to initiate interaction (including photography or recording) with someone after being asked to stop publication of private communication without consent sharing recordings of training sessions with non-participants Consequences of Unacceptable behavior If you believe someone is violating the Code of Conduct, we ask that you report it to any of the workshop organizers. This is a community-led workshop, and we value the involvement of everyone in the community. We are committed to creating a friendly and respectful place for learning, teaching and contributing. All participants in our events and communications are expected to show respect and courtesy to others. To make clear what is expected, everyone participating in this conference and its activities is required to conform to the Code of Conduct. This Code of Conduct applies to all spaces affiliated with the conference, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. Workshop organizers are expected to assist with the enforcement of the Code of Conduct. Participants who are asked to stop any inappropriate behavior are expected to comply immediately. This applies to any workshop events and platforms, either online or in-person. If a participant engages in behavior that violates this code of conduct, the organizers may warn the offender, ask them to leave the event or platform, or investigate the Code of Conduct violation and impose appropriate sanctions. Attribution This code of conduct is largely mirrored from the one used by ML4Science that in turn modelled it on the Software Carpentry's code of conduct .","title":"Code of conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"This workshop is dedicated to providing a welcoming and supportive environment for all people, regardless of background or identity. By participating in this workshop, participants accept to abide by this Code of Conduct and accept the procedures by which any Code of Conduct incidents are resolved. We do not tolerate behavior that is disrespectful or that excludes, intimidates, or causes discomfort to others. We do not tolerate discrimination or harassment based on characteristics that include, but are not limited to, gender identity and expression, sexual orientation, disability, physical appearance, body size, citizenship, nationality, ethnic or social origin, pregnancy, familial status, veteran status, genetic information, religion or belief (or lack thereof), membership of a national minority, property, age, education, socio-economic status, technical choices, and experience level. Everyone who participates in workshop activities is required to conform to this Code of Conduct. It applies to all spaces managed by or affiliated with the workshop, including, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. Workshop hosts are expected to assist with the enforcement of the Code of Conduct. By participating, participants indicate their acceptance of the procedures by which the workshop resolves any Code of Conduct incidents, which may include storage and processing of their personal information.","title":"Code of conduct"},{"location":"code_of_conduct/#expected-behavior","text":"All participants in our events and communications are expected to show respect and courtesy to others. All interactions should be professional regardless of platform: either online or in-person. In order to foster a positive and professional learning environment we encourage the following kinds of behaviors in all workshop events and platforms: Use welcoming and inclusive language Be respectful of different viewpoints and experiences Gracefully accept constructive criticism Focus on what is best for the community Show courtesy and respect towards other community members","title":"Expected behavior"},{"location":"code_of_conduct/#unacceptable-behavior","text":"Examples of unacceptable behavior by participants at any workshop event/platform include: written or verbal comments which have the effect of excluding people on the basis of membership of any specific group causing someone to fear for their safety, such as through stalking, following, or intimidation violent threats or language directed against another person the display of sexual or violent images unwelcome sexual attention nonconsensual or unwelcome physical contact sustained disruption of talks, events or communications insults or put downs sexist, racist, homophobic, transphobic, ableist, or exclusionary jokes excessive swearing incitement to violence, suicide, or self-harm continuing to initiate interaction (including photography or recording) with someone after being asked to stop publication of private communication without consent sharing recordings of training sessions with non-participants","title":"Unacceptable behavior"},{"location":"code_of_conduct/#consequences-of-unacceptable-behavior","text":"If you believe someone is violating the Code of Conduct, we ask that you report it to any of the workshop organizers. This is a community-led workshop, and we value the involvement of everyone in the community. We are committed to creating a friendly and respectful place for learning, teaching and contributing. All participants in our events and communications are expected to show respect and courtesy to others. To make clear what is expected, everyone participating in this conference and its activities is required to conform to the Code of Conduct. This Code of Conduct applies to all spaces affiliated with the conference, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. Workshop organizers are expected to assist with the enforcement of the Code of Conduct. Participants who are asked to stop any inappropriate behavior are expected to comply immediately. This applies to any workshop events and platforms, either online or in-person. If a participant engages in behavior that violates this code of conduct, the organizers may warn the offender, ask them to leave the event or platform, or investigate the Code of Conduct violation and impose appropriate sanctions.","title":"Consequences of Unacceptable behavior"},{"location":"code_of_conduct/#attribution","text":"This code of conduct is largely mirrored from the one used by ML4Science that in turn modelled it on the Software Carpentry's code of conduct .","title":"Attribution"},{"location":"computational_skills/","text":"Computational skills graph LR Scientific_computing[Scientific computing] --> Using_HPC_systems[Using HPC systems] Using_HPC_systems --> Programming[Programming] Using_HPC_systems --> Data_analysis_and_visualization[Data analysis and visualization] click Scientific_computing \"https://gjbex.github.io/Training-sessions/scientific_computing\" \"Scientific computing\" click Using_HPC_systems \"https://gjbex.github.io/Training-sessions/using_hpc_systems\" \"Using HPC systems\" click Programming \"https://gjbex.github.io/Training-sessions/programming\" \"Programming\" click Data_analysis_and_visualization \"https://gjbex.github.io/Training-sessions/data_analysis_and_visualization\" \"Data analysis and visualization\"","title":"Computational skills"},{"location":"computational_skills/#computational-skills","text":"graph LR Scientific_computing[Scientific computing] --> Using_HPC_systems[Using HPC systems] Using_HPC_systems --> Programming[Programming] Using_HPC_systems --> Data_analysis_and_visualization[Data analysis and visualization] click Scientific_computing \"https://gjbex.github.io/Training-sessions/scientific_computing\" \"Scientific computing\" click Using_HPC_systems \"https://gjbex.github.io/Training-sessions/using_hpc_systems\" \"Using HPC systems\" click Programming \"https://gjbex.github.io/Training-sessions/programming\" \"Programming\" click Data_analysis_and_visualization \"https://gjbex.github.io/Training-sessions/data_analysis_and_visualization\" \"Data analysis and visualization\"","title":"Computational skills"},{"location":"contact/","text":"Contact information Requests for information or scheduling a training can be addressed to Geert Jan Bex , Hasselt University Many of the training sessions are organized in collaboration with the Vlaams Supercomputer Centrum (VSC) . You can find the schedule of upcoming training sessions on their website.","title":"Contact"},{"location":"contact/#contact-information","text":"Requests for information or scheduling a training can be addressed to Geert Jan Bex , Hasselt University Many of the training sessions are organized in collaboration with the Vlaams Supercomputer Centrum (VSC) . You can find the schedule of upcoming training sessions on their website.","title":"Contact information"},{"location":"cpp/","text":"C++ programming C++ is an important language for scientific programming and HPC. graph TD Scientific_Cpp[Scientific C++] --> Cpp_software_engineering[C++ software engineering] Cpp_software_engineering --> Defensive_programming_and_debugging[Defensive programming and debugging] Cpp_software_engineering --> Code_optimization[Code optimization] Defensive_programming_and_debugging --> Code_optimization Code_optimization --> Parallel_programming_with_OpenMP[Parallel programming with OpenMP] Code_optimization --> Parallel_programming_with_MPI[Parallel programming with MPI] Parallel_programming_with_OpenMP --> Parallel_programming_with_MPI Code_optimization --> GPU_programming[GPU programming] Code_optimization --> Parallel_programming_with_STL_and_TBB[Parallel programming with STL and TBB] Parallel_programming_with_OpenMP --> GPU_programming click Scientific_Cpp \"https://gjbex.github.io/Scientific-C-plus-plus/\" \"Scientific C++\" click Cpp_software_engineering \"https://gjbex.github.io/C-plus-plus-software-engineering/\" \"C++ software engineering\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_programming_with_OpenMP \"https://gjbex.github.io/Training-sessions/parallel_programming_with_openmp\" \"Parallel programming with OpenMP\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click GPU_programming \"https://gjbex.github.io/GPU-programming/\" \"GPU programming\" click Parallel_programming_with_STL_and_TBB \"https://gjbex.github.io/Training-sessions/parallel_programming_with_stl_and_tbb\" \"Parallel programming with STL and TBB\"","title":"C++"},{"location":"cpp/#c-programming","text":"C++ is an important language for scientific programming and HPC. graph TD Scientific_Cpp[Scientific C++] --> Cpp_software_engineering[C++ software engineering] Cpp_software_engineering --> Defensive_programming_and_debugging[Defensive programming and debugging] Cpp_software_engineering --> Code_optimization[Code optimization] Defensive_programming_and_debugging --> Code_optimization Code_optimization --> Parallel_programming_with_OpenMP[Parallel programming with OpenMP] Code_optimization --> Parallel_programming_with_MPI[Parallel programming with MPI] Parallel_programming_with_OpenMP --> Parallel_programming_with_MPI Code_optimization --> GPU_programming[GPU programming] Code_optimization --> Parallel_programming_with_STL_and_TBB[Parallel programming with STL and TBB] Parallel_programming_with_OpenMP --> GPU_programming click Scientific_Cpp \"https://gjbex.github.io/Scientific-C-plus-plus/\" \"Scientific C++\" click Cpp_software_engineering \"https://gjbex.github.io/C-plus-plus-software-engineering/\" \"C++ software engineering\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_programming_with_OpenMP \"https://gjbex.github.io/Training-sessions/parallel_programming_with_openmp\" \"Parallel programming with OpenMP\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click GPU_programming \"https://gjbex.github.io/GPU-programming/\" \"GPU programming\" click Parallel_programming_with_STL_and_TBB \"https://gjbex.github.io/Training-sessions/parallel_programming_with_stl_and_tbb\" \"Parallel programming with STL and TBB\"","title":"C++ programming"},{"location":"data_analysis_and_visualization/","text":"Data analysis and visualization Data analysis and visualization are essential skills for scientific computing. graph TD Scientific_python[Scientific Python] --> Python_for_data_science[Python for data science] Python_for_data_science --> Python_dashboards[Python dashboards] Scientific_python --> Python_for_HPC[Python for HPC] Python_for_data_science --> Python_for_HPC Python_for_data_science --> Generative_ai_for_software_engineering_and_data_analysis[Generative AI for software engineering and data analysis] Python_for_data_science --> Machine_learning_with_Python[Machine learning with Python] Machine_learning_with_Python --> MLOps_on_HPC[MLOps on HPC] Scientific_visualization_with_ParaView[Scientific visualization with ParaView] click Scientific_python \"https://gjbex.github.io/Scientific-Python/\" \"Scientific Python\" click Generative_ai_for_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI for software engineering and data analysis\" click Machine_learning_with_Python \"https://gjbex.github.io/Training-sessions/machine_learning_with_python\" \"Machine learning with Python\" click MLOps_on_HPC \"https://gjbex.github.io/Training-sessions/mlops_on_hpc\" \"MLOps on HPC\" click Scientific_visualization_with_ParaView \"https://gjbex.github.io/Training-sessions/scientific_visualization_with_paraview\" \"Scientific visualization with ParaView\" click Python_dashboards \"https://gjbex.github.io/Python-dashboards/\" \"Python dashboards\" click Python_for_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python for HPC\" click Python_for_data_science \"https://gjbex.github.io/Python-for-data-science/\" \"Python for data science\"","title":"Data analysis and visualization"},{"location":"data_analysis_and_visualization/#data-analysis-and-visualization","text":"Data analysis and visualization are essential skills for scientific computing. graph TD Scientific_python[Scientific Python] --> Python_for_data_science[Python for data science] Python_for_data_science --> Python_dashboards[Python dashboards] Scientific_python --> Python_for_HPC[Python for HPC] Python_for_data_science --> Python_for_HPC Python_for_data_science --> Generative_ai_for_software_engineering_and_data_analysis[Generative AI for software engineering and data analysis] Python_for_data_science --> Machine_learning_with_Python[Machine learning with Python] Machine_learning_with_Python --> MLOps_on_HPC[MLOps on HPC] Scientific_visualization_with_ParaView[Scientific visualization with ParaView] click Scientific_python \"https://gjbex.github.io/Scientific-Python/\" \"Scientific Python\" click Generative_ai_for_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI for software engineering and data analysis\" click Machine_learning_with_Python \"https://gjbex.github.io/Training-sessions/machine_learning_with_python\" \"Machine learning with Python\" click MLOps_on_HPC \"https://gjbex.github.io/Training-sessions/mlops_on_hpc\" \"MLOps on HPC\" click Scientific_visualization_with_ParaView \"https://gjbex.github.io/Training-sessions/scientific_visualization_with_paraview\" \"Scientific visualization with ParaView\" click Python_dashboards \"https://gjbex.github.io/Python-dashboards/\" \"Python dashboards\" click Python_for_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python for HPC\" click Python_for_data_science \"https://gjbex.github.io/Python-for-data-science/\" \"Python for data science\"","title":"Data analysis and visualization"},{"location":"fortran/","text":"Fortran programming Fortran is still a very popular and important programming language in the context of scientific programming and HPC. graph TD Fortran_for_programmers[Fortran for programmers] --> Defensive_programming_and_debugging[Defensive programming and debugging] Fortran_for_programmers --> Code_optimization[Code optimization] Defensive_programming_and_debugging --> Code_optimization Code_optimization --> Parallel_programming_with_OpenMP[Parallel programming with OpenMP] Code_optimization[Code optimization] --> Parallel_programming_with_MPI[Parallel programming with MPI] Parallel_programming_with_OpenMP --> Parallel_programming_with_MPI Code_optimization --> GPU_programming[GPU programming] Parallel_programming_with_OpenMP --> GPU_programming click Fortran_for_programmers \"https://gjbex.github.io/Fortran-for-programmers/\" \"Fortran for programmers\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_programming_with_OpenMP \"https://gjbex.github.io/Training-sessions/parallel_programming_with_openmp\" \"Parallel programming with OpenMP\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click GPU_programming \"https://gjbex.github.io/GPU-programming/\" \"GPU programming\"","title":"Fortran"},{"location":"fortran/#fortran-programming","text":"Fortran is still a very popular and important programming language in the context of scientific programming and HPC. graph TD Fortran_for_programmers[Fortran for programmers] --> Defensive_programming_and_debugging[Defensive programming and debugging] Fortran_for_programmers --> Code_optimization[Code optimization] Defensive_programming_and_debugging --> Code_optimization Code_optimization --> Parallel_programming_with_OpenMP[Parallel programming with OpenMP] Code_optimization[Code optimization] --> Parallel_programming_with_MPI[Parallel programming with MPI] Parallel_programming_with_OpenMP --> Parallel_programming_with_MPI Code_optimization --> GPU_programming[GPU programming] Parallel_programming_with_OpenMP --> GPU_programming click Fortran_for_programmers \"https://gjbex.github.io/Fortran-for-programmers/\" \"Fortran for programmers\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_programming_with_OpenMP \"https://gjbex.github.io/Training-sessions/parallel_programming_with_openmp\" \"Parallel programming with OpenMP\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click GPU_programming \"https://gjbex.github.io/GPU-programming/\" \"GPU programming\"","title":"Fortran programming"},{"location":"generative_ai_for_software_engineering_and_data_analysis/","text":"Generative AI for software engineering and data analysis (3 hours) Generative AI is a useful tool in software engineering and data analysis. However, if you want to use it effectively, you need to understand the basics of the underlying technoligy, and to be aware of potential pitfalls.. After an introduction to the basics of generative AI, various applications will be demoed, and you will be able to experiment with some of them yourself. Tools such as OpenAI's Chat-GPT and GitHub's Copilot will be discussed. Prerequisites: experience in some programming language; familiarity with the Linux command line","title":"Generative AI for software engineering and data analysis (3 hours)"},{"location":"generative_ai_for_software_engineering_and_data_analysis/#generative-ai-for-software-engineering-and-data-analysis-3-hours","text":"Generative AI is a useful tool in software engineering and data analysis. However, if you want to use it effectively, you need to understand the basics of the underlying technoligy, and to be aware of potential pitfalls.. After an introduction to the basics of generative AI, various applications will be demoed, and you will be able to experiment with some of them yourself. Tools such as OpenAI's Chat-GPT and GitHub's Copilot will be discussed. Prerequisites: experience in some programming language; familiarity with the Linux command line","title":"Generative AI for software engineering and data analysis (3 hours)"},{"location":"gpu_computing/","text":"GPU computing GPUs are used more and more in scientific computing, data science and machine learning. graph LR Python_on_GPUs[Python on GPUs] Heterogeneous_programming_with_Kokkos[Heterogeneous programming with Kokkos] GPU_offloading_with_OpenMP[GPU offloading with OpenMP] click Python_on_GPUs \"https://gjbex.github.io/Python-on-GPUs/\" \"Python on GPUs\" click Heterogeneous_programming_with_Kokkos \"https://gjbex.github.io/GPU-programming/\" \"GPU programming\" click GPU_offloading_with_OpenMP \"https://gjbex.github.io/GPU-programming/\" \"GPU offloading with OpenMP\"","title":"GPU computing"},{"location":"gpu_computing/#gpu-computing","text":"GPUs are used more and more in scientific computing, data science and machine learning. graph LR Python_on_GPUs[Python on GPUs] Heterogeneous_programming_with_Kokkos[Heterogeneous programming with Kokkos] GPU_offloading_with_OpenMP[GPU offloading with OpenMP] click Python_on_GPUs \"https://gjbex.github.io/Python-on-GPUs/\" \"Python on GPUs\" click Heterogeneous_programming_with_Kokkos \"https://gjbex.github.io/GPU-programming/\" \"GPU programming\" click GPU_offloading_with_OpenMP \"https://gjbex.github.io/GPU-programming/\" \"GPU offloading with OpenMP\"","title":"GPU computing"},{"location":"hpc_intro/","text":"HPC introduction Although working on High Performance Computing (HPC) infrastructures is not rocket science, there are still a number of things you need to be aware of to do so efficiently. Note that this session is specific for (potential) users of the infrastructure managed by the Vlaams Supercopmuting Centrum (VSC). Subjects: how to access the systems architecture of a cluster shared file systems software stack resource manager and scheduler accounting Prerequisites: familiarity with the Linux command line","title":"HPC introduction"},{"location":"hpc_intro/#hpc-introduction","text":"Although working on High Performance Computing (HPC) infrastructures is not rocket science, there are still a number of things you need to be aware of to do so efficiently. Note that this session is specific for (potential) users of the infrastructure managed by the Vlaams Supercopmuting Centrum (VSC). Subjects: how to access the systems architecture of a cluster shared file systems software stack resource manager and scheduler accounting Prerequisites: familiarity with the Linux command line","title":"HPC introduction"},{"location":"learning_path_data_science/","text":"Data science learning path If you want to do data science on HPC, you can consider following the following training sessions. graph TD Best_practices_for_scientific_computing[Best practices for\\nscientific computing] --> Best_practices_for_data_science_on_HPC[Best practices for\\ndata science on HPC] Linux_intro[Linux introduction] --> HPC_intro[HPC introduction] HPC_intro --> Best_practices_for_data_science_on_HPC Best_practices_for_data_science_on_HPC --> Version_control_with_git[Version control with Git] Version_control_with_git --> MLOps_on_HPC[MLOps on HPC] Python_for_beginners[Python for beginners] --> Python_for_programmers[Python for programmers] Python_for_programmers --> Best_practices_for_data_science_on_HPC Best_practices_for_data_science_on_HPC --> Jupyter_notebooks[Jupyter notebooks] Best_practices_for_data_science_on_HPC --> Containers_on_HPC[Containers on HPC] Best_practices_for_data_science_on_HPC --> Workflows_for_HPC[Workflows for HPC] Best_practices_for_data_science_on_HPC --> Scientific_python[Scientific Python] Python_for_programmers --> Python_software_engineering[Python software engineering] Python_for_programmers --> Scientific_Python[Scientific Python] Jupyter_notebooks --> Scientific_Python Scientific_Python --> Python_for_data_science[Python for data science] Python_for_data_science --> Python_dashboards[Python dashboards] Scientific_Python --> Python_for_HPC[Python for HPC] Python_for_data_science --> Python_for_HPC Python_for_data_science --> Generative_ai_for_software_engineering_and_data_analysis[Generative AI for software\\nengineering and data analysis] Python_for_data_science --> Machine_learning_with_Python[Machine learning with Python] MLOps_on_HPC --> Machine_learning_with_Python click Best_practices_for_scientific_computing \"https://gjbex.github.io/Best-practices-for-scientific-computing/\" \"Best practices for scientific computing\" click Best_practices_for_data_science_on_HPC \"https://gjbex.github.io/Best-practices-for-data-science-on-HPC/\" \"Best practices for data science on HPC\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git\" \"Version control with Git\" click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Workflows_for_HPC \"https://gjbex.github.io/Workflows-for-HPC/\" \"Workflows for HPC\" click MLOps_on_HPC \"https://gjbex.github.io/MLOps-on-HPC/\" \"MLOps on HPC\" click Python_for_beginners \"https://gjbex.github.io/Python-for-beginners/\" \"Python for beginners\" click Python_for_programmers \"https://gjbex.github.io/Python-for-programmers/\" \"Python for programmers\" click Python_software_engineering \"https://gjbex.github.io/Python-software-engineering/\" \"Python software engineering\" click Scientific_Python \"https://gjbex.github.io/Scientific-Python/\" \"Scientific Python\" click Generative_ai_for_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI for software engineering and data analysis\" click Machine_learning_with_Python \"https://gjbex.github.io/Training-sessions/machine_learning_with_python\" \"Machine learning with Python\" click MLOps_on_HPC \"https://gjbex.github.io/Training-sessions/mlops_on_hpc\" \"MLOps on HPC\" click Python_dashboards \"https://gjbex.github.io/Python-dashboards/\" \"Python dashboards\" click Jupyter_notebooks \"https://gjbex.github.io/Jupyter-notebooks/\" \"Jupyter notebooks\" click Python_for_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python for HPC\" click Python_for_data_science \"https://gjbex.github.io/Python-for-data-science/\" \"Python for data science\" If you are new to scientific computing, you may want to start with \" Best practices for scientific computing \". The next step is to fammliarize yourself with the basics of working on the Linux command line and the HPC infrastructure . Since you need some programming skills to do data science, you may want to start with \" Python for beginners \", followed by \" Python for programmers \". Since there are quite some best practices specific to data science on HPC, you may want to follow the \" Best practices for data science on HPC \" training session. Learn how to manage your code with version control in the \" Version control with git \" training session, and your data and experiments with MLOps in the \" MLOps on HPC \" training session. Containers are useful tools in the context of data science both to create a complete, stable and portable development environment, but also as a means to distribute your software. For more information on this topic, see \" Containers on HPC \". Workflows are essential to automate your data science tasks. For more information on this topic, see \" Workflows for HPC \". \" Scientific Python \" will introduce you to the Python libraries that are commonly used in the context of scientific computing, while \" Python for data science \" will introduce you to the Python libraries that are commonly used in the context of data science. Performance is of course important in data science on HPC, so you may want to follow the \" Python for HPC \" training session.","title":"Data science"},{"location":"learning_path_data_science/#data-science-learning-path","text":"If you want to do data science on HPC, you can consider following the following training sessions. graph TD Best_practices_for_scientific_computing[Best practices for\\nscientific computing] --> Best_practices_for_data_science_on_HPC[Best practices for\\ndata science on HPC] Linux_intro[Linux introduction] --> HPC_intro[HPC introduction] HPC_intro --> Best_practices_for_data_science_on_HPC Best_practices_for_data_science_on_HPC --> Version_control_with_git[Version control with Git] Version_control_with_git --> MLOps_on_HPC[MLOps on HPC] Python_for_beginners[Python for beginners] --> Python_for_programmers[Python for programmers] Python_for_programmers --> Best_practices_for_data_science_on_HPC Best_practices_for_data_science_on_HPC --> Jupyter_notebooks[Jupyter notebooks] Best_practices_for_data_science_on_HPC --> Containers_on_HPC[Containers on HPC] Best_practices_for_data_science_on_HPC --> Workflows_for_HPC[Workflows for HPC] Best_practices_for_data_science_on_HPC --> Scientific_python[Scientific Python] Python_for_programmers --> Python_software_engineering[Python software engineering] Python_for_programmers --> Scientific_Python[Scientific Python] Jupyter_notebooks --> Scientific_Python Scientific_Python --> Python_for_data_science[Python for data science] Python_for_data_science --> Python_dashboards[Python dashboards] Scientific_Python --> Python_for_HPC[Python for HPC] Python_for_data_science --> Python_for_HPC Python_for_data_science --> Generative_ai_for_software_engineering_and_data_analysis[Generative AI for software\\nengineering and data analysis] Python_for_data_science --> Machine_learning_with_Python[Machine learning with Python] MLOps_on_HPC --> Machine_learning_with_Python click Best_practices_for_scientific_computing \"https://gjbex.github.io/Best-practices-for-scientific-computing/\" \"Best practices for scientific computing\" click Best_practices_for_data_science_on_HPC \"https://gjbex.github.io/Best-practices-for-data-science-on-HPC/\" \"Best practices for data science on HPC\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git\" \"Version control with Git\" click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Workflows_for_HPC \"https://gjbex.github.io/Workflows-for-HPC/\" \"Workflows for HPC\" click MLOps_on_HPC \"https://gjbex.github.io/MLOps-on-HPC/\" \"MLOps on HPC\" click Python_for_beginners \"https://gjbex.github.io/Python-for-beginners/\" \"Python for beginners\" click Python_for_programmers \"https://gjbex.github.io/Python-for-programmers/\" \"Python for programmers\" click Python_software_engineering \"https://gjbex.github.io/Python-software-engineering/\" \"Python software engineering\" click Scientific_Python \"https://gjbex.github.io/Scientific-Python/\" \"Scientific Python\" click Generative_ai_for_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI for software engineering and data analysis\" click Machine_learning_with_Python \"https://gjbex.github.io/Training-sessions/machine_learning_with_python\" \"Machine learning with Python\" click MLOps_on_HPC \"https://gjbex.github.io/Training-sessions/mlops_on_hpc\" \"MLOps on HPC\" click Python_dashboards \"https://gjbex.github.io/Python-dashboards/\" \"Python dashboards\" click Jupyter_notebooks \"https://gjbex.github.io/Jupyter-notebooks/\" \"Jupyter notebooks\" click Python_for_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python for HPC\" click Python_for_data_science \"https://gjbex.github.io/Python-for-data-science/\" \"Python for data science\" If you are new to scientific computing, you may want to start with \" Best practices for scientific computing \". The next step is to fammliarize yourself with the basics of working on the Linux command line and the HPC infrastructure . Since you need some programming skills to do data science, you may want to start with \" Python for beginners \", followed by \" Python for programmers \". Since there are quite some best practices specific to data science on HPC, you may want to follow the \" Best practices for data science on HPC \" training session. Learn how to manage your code with version control in the \" Version control with git \" training session, and your data and experiments with MLOps in the \" MLOps on HPC \" training session. Containers are useful tools in the context of data science both to create a complete, stable and portable development environment, but also as a means to distribute your software. For more information on this topic, see \" Containers on HPC \". Workflows are essential to automate your data science tasks. For more information on this topic, see \" Workflows for HPC \". \" Scientific Python \" will introduce you to the Python libraries that are commonly used in the context of scientific computing, while \" Python for data science \" will introduce you to the Python libraries that are commonly used in the context of data science. Performance is of course important in data science on HPC, so you may want to follow the \" Python for HPC \" training session.","title":"Data science learning path"},{"location":"learning_path_developing_python_hpc_applications/","text":"HPC python application development learning path If you want to develop HPC applications using Python, you can consider following the following training sessions. graph TD Python_for_beginners[Python for beginners] --> Python_for_programmers[Python for programmers] Version_control_with_git[Version control with Git] --> Python_for_programmers Linux_intro[Linux introduction] --> HPC_intro[HPC introduction] Python_for_programmers --> Scientific_Python[Scientific Python] HPC_intro --> Python_for_HPC[Python for HPC] Python_for_programmers --> Python_software_engineering[Python software engineering] Scientific_Python --> Python_for_HPC[Python for HPC] Scientific_Cpp[Scientific C++] --> Python_for_HPC Python_for_HPC --> Python_on_GPUs[Python on GPUs] Python_for_HPC --> Parallel_programming_with_MPI[Parallel programming with MPI] click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git\" \"Version control with Git\" click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Python_for_beginners \"https://gjbex.github.io/Python-for-beginners/\" \"Python for beginners\" click Python_for_programmers \"https://gjbex.github.io/Python-for-programmers/\" \"Python for programmers\" click Python_software_engineering \"https://gjbex.github.io/Python-software-engineering/\" \"Python software engineering\" click Scientific_Python \"https://gjbex.github.io/Scientific-Python/\" \"Scientific Python\" click Python_for_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python for HPC\" click Scientific_Cpp \"https://gjbex.github.io/Scientific-C-plus-plus/\" \"Scientific C++\" click Python_on_GPUs \"https://gjbex.github.io/Python-on-GPUs/\" \"Python on GPUs\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" If you are new to development using Python, you may want to start with \" Python for beginners \" and \" Python for programmers \". It is important that you improve you software engineering skills, so you may want to follow the \" Python software engineering \" and \" Version control with git \" training sessions. Python has a rich ecosystem of libraries for scientific computing, so you may want to follow the \" Scientific Python \" training session. Since you will be working on HPC systems, you need to be familiar with the \" Linux introduction \" and \" HPC introduction \" training sessions. Finally, you may want to follow the \" Python for HPC \" training session to learn how to write efficient Python code for HPC systems. If you intend to interface Python with C++ code, you may want to follow the \" Scientific C++ \" training session as well. Perhaps you want to leverage the power of GPUs in your Python applications, in which case you may want to follow the \" Python on GPUs \" training session.","title":"Python HPC application development"},{"location":"learning_path_developing_python_hpc_applications/#hpc-python-application-development-learning-path","text":"If you want to develop HPC applications using Python, you can consider following the following training sessions. graph TD Python_for_beginners[Python for beginners] --> Python_for_programmers[Python for programmers] Version_control_with_git[Version control with Git] --> Python_for_programmers Linux_intro[Linux introduction] --> HPC_intro[HPC introduction] Python_for_programmers --> Scientific_Python[Scientific Python] HPC_intro --> Python_for_HPC[Python for HPC] Python_for_programmers --> Python_software_engineering[Python software engineering] Scientific_Python --> Python_for_HPC[Python for HPC] Scientific_Cpp[Scientific C++] --> Python_for_HPC Python_for_HPC --> Python_on_GPUs[Python on GPUs] Python_for_HPC --> Parallel_programming_with_MPI[Parallel programming with MPI] click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git\" \"Version control with Git\" click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Python_for_beginners \"https://gjbex.github.io/Python-for-beginners/\" \"Python for beginners\" click Python_for_programmers \"https://gjbex.github.io/Python-for-programmers/\" \"Python for programmers\" click Python_software_engineering \"https://gjbex.github.io/Python-software-engineering/\" \"Python software engineering\" click Scientific_Python \"https://gjbex.github.io/Scientific-Python/\" \"Scientific Python\" click Python_for_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python for HPC\" click Scientific_Cpp \"https://gjbex.github.io/Scientific-C-plus-plus/\" \"Scientific C++\" click Python_on_GPUs \"https://gjbex.github.io/Python-on-GPUs/\" \"Python on GPUs\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" If you are new to development using Python, you may want to start with \" Python for beginners \" and \" Python for programmers \". It is important that you improve you software engineering skills, so you may want to follow the \" Python software engineering \" and \" Version control with git \" training sessions. Python has a rich ecosystem of libraries for scientific computing, so you may want to follow the \" Scientific Python \" training session. Since you will be working on HPC systems, you need to be familiar with the \" Linux introduction \" and \" HPC introduction \" training sessions. Finally, you may want to follow the \" Python for HPC \" training session to learn how to write efficient Python code for HPC systems. If you intend to interface Python with C++ code, you may want to follow the \" Scientific C++ \" training session as well. Perhaps you want to leverage the power of GPUs in your Python applications, in which case you may want to follow the \" Python on GPUs \" training session.","title":"HPC python application development learning path"},{"location":"learning_path_hpc_application_development/","text":"HPC application development learning path If you want to develop HPC applications, you can consider following the following training sessions. graph TD Best_practices_for_scientific_computing[Best practices for scientific computing] --> Version_control_with_git[Version control with Git] Best_practices_for_scientific_computing[Best practices for scientific computing] --> Linux_intro[Linux introduction] Linux_intro --> HPC_intro[HPC introduction] HPC_intro --> Containers_on_HPC[Containers on HPC] Best_practices_for_scientific_computing --> Programming[Programming] Programming --> Defensive_programming_and_debugging[Defensive programming and debugging] Defensive_programming_and_debugging --> Code_optimization[Code optimization] Programming --> Code_optimization Programming --> Generative_AI_in_software_engineering_and_data_analysis[Generative AI in software\\nengineering and data analysis] HPC_intro --> Defensive_programming_and_debugging Code_optimization --> Parallel_computing[Parallel computing] Code_optimization --> GPU_computing[GPU computing] click Best_practices_for_scientific_computing \"https://gjbex.github.io/Best-practices-for-scientific-computing/\" \"Best practices for scientific computing\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git\" \"Version control with Git\" click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Generative_ai_for_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI in software\\nengineering and data analysis\" click Programming \"https://gjbex.github.io/Training-sessions/programming\" \"Programming\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_computing \"https://gjbex.github.io/Training-sessions/parallel_computing\" \"Parallel computing\" click GPU_computing \"https://gjbex.github.io/Training-sessions/gpu_computing\" \"GPU computing\" If you are new to software development in the context of scientific computing, you may want to start with \" Best practices for scientific computing \". The next step is to fammliarize yourself with the basics of working on the Linux command line and the HPC infrastructure . Of course, you coding skills should be up to par. For more information on this topic, see \" Programming \". Version control is an essential part of software engineering. For more information on this topic, see \" Version control with git \". Containers are useful tools in the context of software engineering both to create a complete, stable and portable development environment, but also as a means to distribute your software. Writing robust code that has been well-tested is an essential part of software development. Having tests in place is also essential when trying to optimize your code. For more information on this topic, see \" Defensive programming and debugging \". Effectively optimizing your code implies that you have a thorough understanding of the hardware you are using and how your code interacts with it. For more information on this topic, see \" Code optimization \". Parallel or GPU computing is often required to take full advantage of modern compute nodes. For more information on this topic, see \" Parallel computing \" and \" GPU computing \".","title":"HPC applciation development"},{"location":"learning_path_hpc_application_development/#hpc-application-development-learning-path","text":"If you want to develop HPC applications, you can consider following the following training sessions. graph TD Best_practices_for_scientific_computing[Best practices for scientific computing] --> Version_control_with_git[Version control with Git] Best_practices_for_scientific_computing[Best practices for scientific computing] --> Linux_intro[Linux introduction] Linux_intro --> HPC_intro[HPC introduction] HPC_intro --> Containers_on_HPC[Containers on HPC] Best_practices_for_scientific_computing --> Programming[Programming] Programming --> Defensive_programming_and_debugging[Defensive programming and debugging] Defensive_programming_and_debugging --> Code_optimization[Code optimization] Programming --> Code_optimization Programming --> Generative_AI_in_software_engineering_and_data_analysis[Generative AI in software\\nengineering and data analysis] HPC_intro --> Defensive_programming_and_debugging Code_optimization --> Parallel_computing[Parallel computing] Code_optimization --> GPU_computing[GPU computing] click Best_practices_for_scientific_computing \"https://gjbex.github.io/Best-practices-for-scientific-computing/\" \"Best practices for scientific computing\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git\" \"Version control with Git\" click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Generative_ai_for_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI in software\\nengineering and data analysis\" click Programming \"https://gjbex.github.io/Training-sessions/programming\" \"Programming\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_computing \"https://gjbex.github.io/Training-sessions/parallel_computing\" \"Parallel computing\" click GPU_computing \"https://gjbex.github.io/Training-sessions/gpu_computing\" \"GPU computing\" If you are new to software development in the context of scientific computing, you may want to start with \" Best practices for scientific computing \". The next step is to fammliarize yourself with the basics of working on the Linux command line and the HPC infrastructure . Of course, you coding skills should be up to par. For more information on this topic, see \" Programming \". Version control is an essential part of software engineering. For more information on this topic, see \" Version control with git \". Containers are useful tools in the context of software engineering both to create a complete, stable and portable development environment, but also as a means to distribute your software. Writing robust code that has been well-tested is an essential part of software development. Having tests in place is also essential when trying to optimize your code. For more information on this topic, see \" Defensive programming and debugging \". Effectively optimizing your code implies that you have a thorough understanding of the hardware you are using and how your code interacts with it. For more information on this topic, see \" Code optimization \". Parallel or GPU computing is often required to take full advantage of modern compute nodes. For more information on this topic, see \" Parallel computing \" and \" GPU computing \".","title":"HPC application development learning path"},{"location":"learning_path_using_hpc_applications/","text":"HPC application development learning path If you want to run HPC applications, you can consider following the following training sessions. graph TD Best_practices_for_scientific_computing[Best practices for scientific computing] --> Version_control_with_git[Version control with Git] Best_practices_for_scientific_computing[Best practices for scientific computing] --> Linux_intro[Linux introduction] Linux_intro --> HPC_intro[HPC introduction] HPC_intro --> Workflows_for_HPC[Workflows for HPC] click Best_practices_for_scientific_computing \"https://gjbex.github.io/Best-practices-for-scientific-computing/\" \"Best practices for scientific computing\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git\" \"Version control with Git\" click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Workflows_for_HPC \"https://gjbex.github.io/Workflows-for-HPC/\" \"Workflows for HPC\" If you are new to running HPC applications in the context of scientific computing, you may want to start with \" Best practices for scientific computing \". The next step is to fammliarize yourself with the basics of working on the Linux command line and the HPC infrastructure . Version control is an essential part of reproducible scientific research. For more information on this topic, see \" Version control with git \". Depending on the HPC application you want to run, you may want to learn about \" Workflows for HPC \".","title":"Using HPC applications"},{"location":"learning_path_using_hpc_applications/#hpc-application-development-learning-path","text":"If you want to run HPC applications, you can consider following the following training sessions. graph TD Best_practices_for_scientific_computing[Best practices for scientific computing] --> Version_control_with_git[Version control with Git] Best_practices_for_scientific_computing[Best practices for scientific computing] --> Linux_intro[Linux introduction] Linux_intro --> HPC_intro[HPC introduction] HPC_intro --> Workflows_for_HPC[Workflows for HPC] click Best_practices_for_scientific_computing \"https://gjbex.github.io/Best-practices-for-scientific-computing/\" \"Best practices for scientific computing\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git\" \"Version control with Git\" click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Workflows_for_HPC \"https://gjbex.github.io/Workflows-for-HPC/\" \"Workflows for HPC\" If you are new to running HPC applications in the context of scientific computing, you may want to start with \" Best practices for scientific computing \". The next step is to fammliarize yourself with the basics of working on the Linux command line and the HPC infrastructure . Version control is an essential part of reproducible scientific research. For more information on this topic, see \" Version control with git \". Depending on the HPC application you want to run, you may want to learn about \" Workflows for HPC \".","title":"HPC application development learning path"},{"location":"license/","text":"Attribution 4.0 International ======================================================================= Creative Commons Corporation (\"Creative Commons\") is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an \"as-is\" basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible. Using Creative Commons Public Licenses Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses. Considerations for licensors: Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC- licensed material, or material used under an exception or limitation to copyright. More considerations for licensors: wiki.creativecommons.org/Considerations_for_licensors Considerations for the public: By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensor's permission is not necessary for any reason--for example, because of any applicable exception or limitation to copyright--then that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. More_considerations for the public: wiki.creativecommons.org/Considerations_for_licensees ======================================================================= Creative Commons Attribution 4.0 International Public License By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions. Section 1 -- Definitions. a. Adapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image. b. Adapter's License means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License. c. Copyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights. d. Effective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements. e. Exceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material. f. Licensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License. g. Licensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license. h. Licensor means the individual(s) or entity(ies) granting rights under this Public License. i. Share means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them. j. Sui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world. k. You means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning. Section 2 -- Scope. a. License grant. 1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to: a. reproduce and Share the Licensed Material, in whole or in part; and b. produce, reproduce, and Share Adapted Material. 2. Exceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions. 3. Term. The term of this Public License is specified in Section 6(a). 4. Media and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a) (4) never produces Adapted Material. 5. Downstream recipients. a. Offer from the Licensor -- Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License. b. No downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material. 6. No endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i). b. Other rights. 1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise. 2. Patent and trademark rights are not licensed under this Public License. 3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties. Section 3 -- License Conditions. Your exercise of the Licensed Rights is expressly made subject to the following conditions. a. Attribution. 1. If You Share the Licensed Material (including in modified form), You must: a. retain the following if it is supplied by the Licensor with the Licensed Material: i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated); ii. a copyright notice; iii. a notice that refers to this Public License; iv. a notice that refers to the disclaimer of warranties; v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable; b. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and c. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License. 2. You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information. 3. If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable. 4. If You Share Adapted Material You produce, the Adapter's License You apply must not prevent recipients of the Adapted Material from complying with this Public License. Section 4 -- Sui Generis Database Rights. Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material: a. for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database; b. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material; and c. You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database. For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights. Section 5 -- Disclaimer of Warranties and Limitation of Liability. a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS, IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU. b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES, COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR IN PART, THIS LIMITATION MAY NOT APPLY TO YOU. c. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability. Section 6 -- Term and Termination. a. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically. b. Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates: 1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or 2. upon express reinstatement by the Licensor. For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License. c. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License. d. Sections 1, 5, 6, 7, and 8 survive termination of this Public License. Section 7 -- Other Terms and Conditions. a. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed. b. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License. Section 8 -- Interpretation. a. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License. b. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions. c. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor. d. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority. ======================================================================= Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the \u201cLicensor.\u201d The text of the Creative Commons public licenses is dedicated to the public domain under the CC0 Public Domain Dedication. Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark \"Creative Commons\" or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses. Creative Commons may be contacted at creativecommons.org.","title":"License"},{"location":"linux_intro/","text":"Linux introduction In HPC, most interaction with the systems is through the terminal and a shell. Working efficiently in such an environment saves a lot of time and frustration. In this training, you will learn the basics of bash, as well as some Linux OS concepts. Subjects: interacting with files and directories editors: nano, and hints at more sophisticated editors process management sharing: file and directory permissions searching: find and grep compressed files and archives: tar, gzip copying to/from remote systems: scp, sftp, rclone Prerequisites: none","title":"Linux introduction"},{"location":"linux_intro/#linux-introduction","text":"In HPC, most interaction with the systems is through the terminal and a shell. Working efficiently in such an environment saves a lot of time and frustration. In this training, you will learn the basics of bash, as well as some Linux OS concepts. Subjects: interacting with files and directories editors: nano, and hints at more sophisticated editors process management sharing: file and directory permissions searching: find and grep compressed files and archives: tar, gzip copying to/from remote systems: scp, sftp, rclone Prerequisites: none","title":"Linux introduction"},{"location":"parallel_computing/","text":"Parallel computing Parallel computing will help to exploit the full potential of modern hardware in general and HPC systems in particular. graph LR Parallel_programming_with_OpenMP[Parallel programming with OpenMP] --> Parallel_programming_with_MPI[Parallel programming with MPI] Parallel_programming_with_OpenMP[Parallel programming with OpenMP] --> GPU_offloading_with_OpenMP[GPU offloading with OpenMP] Python_on_HPC[Python on HPC] --> Parallel_programming_with_MPI Parallel_programming_with_STL_and_TBB[Parallel programming with STL and TBB] click Parallel_programming_with_OpenMP \"https://gjbex.github.io/Training-sessions/parallel_programming_with_openmp\" \"Parallel programming with OpenMP\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click Python_on_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python on HPC\" click Parallel_programming_with_STL_and_TBB \"https://gjbex.github.io/Training-sessions/parallel_programming_with_stl_and_tbb\" \"Parallel programming with STL and TBB\" click GPU_offloading_with_OpenMP \"https://gjbex.github.io/GPU-programming/\" \"GPU offloading with OpenMP\"","title":"Parallel computing"},{"location":"parallel_computing/#parallel-computing","text":"Parallel computing will help to exploit the full potential of modern hardware in general and HPC systems in particular. graph LR Parallel_programming_with_OpenMP[Parallel programming with OpenMP] --> Parallel_programming_with_MPI[Parallel programming with MPI] Parallel_programming_with_OpenMP[Parallel programming with OpenMP] --> GPU_offloading_with_OpenMP[GPU offloading with OpenMP] Python_on_HPC[Python on HPC] --> Parallel_programming_with_MPI Parallel_programming_with_STL_and_TBB[Parallel programming with STL and TBB] click Parallel_programming_with_OpenMP \"https://gjbex.github.io/Training-sessions/parallel_programming_with_openmp\" \"Parallel programming with OpenMP\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click Python_on_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python on HPC\" click Parallel_programming_with_STL_and_TBB \"https://gjbex.github.io/Training-sessions/parallel_programming_with_stl_and_tbb\" \"Parallel programming with STL and TBB\" click GPU_offloading_with_OpenMP \"https://gjbex.github.io/GPU-programming/\" \"GPU offloading with OpenMP\"","title":"Parallel computing"},{"location":"parallel_programming_with_mpi/","text":"Parallel programming with MPI (14 hours) MPI (Message Passing Interface) is the de-facto standard for distributed parallel programming of scientific applications. It specifies language bindings for C and Fortran. This training covers the MPI 3.1 standard, but also emphasizes potential pitfalls and best practices. Subjects: process model and language bindings messages and point-to-point communication non-blocking communication collective communication groups, communicators and virtual topologies one-sided communication shared memory derived data types parallel I/O best practices Prerequisites: experience in C, C++, Fortran or Python programming; for the section on hybrid programming, notions of OpenMP are required.","title":"Parallel programming with MPI (14 hours)"},{"location":"parallel_programming_with_mpi/#parallel-programming-with-mpi-14-hours","text":"MPI (Message Passing Interface) is the de-facto standard for distributed parallel programming of scientific applications. It specifies language bindings for C and Fortran. This training covers the MPI 3.1 standard, but also emphasizes potential pitfalls and best practices. Subjects: process model and language bindings messages and point-to-point communication non-blocking communication collective communication groups, communicators and virtual topologies one-sided communication shared memory derived data types parallel I/O best practices Prerequisites: experience in C, C++, Fortran or Python programming; for the section on hybrid programming, notions of OpenMP are required.","title":"Parallel programming with MPI (14 hours)"},{"location":"parallel_programming_with_openmp/","text":"Parallel programming with OpenMP (7 hours) OpenMP provides a very convenient programming model for scientific applications that run multiple threads. It is supported by C, C++ and Fortran compilers. Its main advantage is that it is mostly used through annotation of code, which makes it easy to pick low hanging fruit when starting to parallelize code. The training covers OpenMP 4.5, and emphasizes pitfalls and best practices. Subjects: programming and execution model worksharing directives data environment tasking SIMD constructs thread placement pitfalls and best practices Prerequisites: experience in C, C++, or Fortran.","title":"Parallel programming with OpenMP (7 hours)"},{"location":"parallel_programming_with_openmp/#parallel-programming-with-openmp-7-hours","text":"OpenMP provides a very convenient programming model for scientific applications that run multiple threads. It is supported by C, C++ and Fortran compilers. Its main advantage is that it is mostly used through annotation of code, which makes it easy to pick low hanging fruit when starting to parallelize code. The training covers OpenMP 4.5, and emphasizes pitfalls and best practices. Subjects: programming and execution model worksharing directives data environment tasking SIMD constructs thread placement pitfalls and best practices Prerequisites: experience in C, C++, or Fortran.","title":"Parallel programming with OpenMP (7 hours)"},{"location":"parallel_programming_with_stl_and_tbb/","text":"Parallel programming with the STL and Threading Building Blocks (3 hours) Out of the box, the STL contains many algorithms that can be run in parallel. In this training, you will learn how to do that, and what the performance benefits may be. Threading Building Blocks (TBB) is a C++ template library for developing shared memory applications. It integrates well with the C++ Standard Template Library (STL) and can be used with any modern C++ compiler. TBB is especially suited for nested parallelism, and pipelining when part of the application can use accelerator hardware. Subjects: STL parallel algorithms Threading Building Blocks programming and execution model recap of required C++ features algorithms: parallel_for , parallel_reduce , parallel_do task based programming data-flow programming, task graphs pitfalls and best practices Prerequisites: experience in C++ programming","title":"Parallel programming with the STL and Threading Building Blocks (3 hours)"},{"location":"parallel_programming_with_stl_and_tbb/#parallel-programming-with-the-stl-and-threading-building-blocks-3-hours","text":"Out of the box, the STL contains many algorithms that can be run in parallel. In this training, you will learn how to do that, and what the performance benefits may be. Threading Building Blocks (TBB) is a C++ template library for developing shared memory applications. It integrates well with the C++ Standard Template Library (STL) and can be used with any modern C++ compiler. TBB is especially suited for nested parallelism, and pipelining when part of the application can use accelerator hardware. Subjects: STL parallel algorithms Threading Building Blocks programming and execution model recap of required C++ features algorithms: parallel_for , parallel_reduce , parallel_do task based programming data-flow programming, task graphs pitfalls and best practices Prerequisites: experience in C++ programming","title":"Parallel programming with the STL and Threading Building Blocks (3 hours)"},{"location":"programming/","text":"Programming graph LR Python[Python] --> Software_engineering[Software engineering] C[C] --> Software_engineering Cpp[C++] --> Software_engineering Fortran[Fortran] --> Software_engineering Julia[Julia] --> Software_engineering Software_engineering --> Parallel_computing[Parallel computing] Software_engineering --> GPU_computing[GPU computing] click Python \"https://gjbex.github.io/Training-sessions/python\" \"Python\" click C \"https://gjbex.github.io/Training-sessions/c\" \"C\" click Cpp \"https://gjbex.github.io/Training-sessions/cpp\" \"C++\" click Fortran \"https://gjbex.github.io/Training-sessions/fortran\" \"Fortran\" click Julia \"https://gjbex.github.io/Julia_good_bad_ugly/\" \"Julia\" click Software_engineering \"https://gjbex.github.io/Training-sessions/software_engineering\" \"Software engineering\" click Parallel_computing \"https://gjbex.github.io/Training-sessions/parallel_computing\" \"Parallel computing\" click GPU_computing \"https://gjbex.github.io/Training-sessions/gpu_computing\" \"GPU computing\" Developing scientific programming entails a lot more than simply knowing how to write code in your favorite programming language. It requires knowledge of software engineering principles such as proper software design, version control, testing, and documentation. If your application is performance-critical, you may need to consider parallel computing or GPU computing.","title":"Programming"},{"location":"programming/#programming","text":"graph LR Python[Python] --> Software_engineering[Software engineering] C[C] --> Software_engineering Cpp[C++] --> Software_engineering Fortran[Fortran] --> Software_engineering Julia[Julia] --> Software_engineering Software_engineering --> Parallel_computing[Parallel computing] Software_engineering --> GPU_computing[GPU computing] click Python \"https://gjbex.github.io/Training-sessions/python\" \"Python\" click C \"https://gjbex.github.io/Training-sessions/c\" \"C\" click Cpp \"https://gjbex.github.io/Training-sessions/cpp\" \"C++\" click Fortran \"https://gjbex.github.io/Training-sessions/fortran\" \"Fortran\" click Julia \"https://gjbex.github.io/Julia_good_bad_ugly/\" \"Julia\" click Software_engineering \"https://gjbex.github.io/Training-sessions/software_engineering\" \"Software engineering\" click Parallel_computing \"https://gjbex.github.io/Training-sessions/parallel_computing\" \"Parallel computing\" click GPU_computing \"https://gjbex.github.io/Training-sessions/gpu_computing\" \"GPU computing\" Developing scientific programming entails a lot more than simply knowing how to write code in your favorite programming language. It requires knowledge of software engineering principles such as proper software design, version control, testing, and documentation. If your application is performance-critical, you may need to consider parallel computing or GPU computing.","title":"Programming"},{"location":"python/","text":"Python programming Python is a versatile programming language that is used in many domains. graph TD Python_for_beginners[Python for beginners] --> Python_for_programmers[Python for programmers] Python_for_programmers --> Python_software_engineering[Python software engineering] Python_for_programmers --> Scientific_Python[Scientific Python] Scientific_Python --> Python_for_data_science[Python for data science] Python_for_programmers --> Python_for_data_science Python_for_programmers --> Machine_learning_with_Python[Machine learning with Python] Python_for_data_science --> Machine_learning_with_Python Python_for_data_science --> Python_dashboards[Python dashboards] Machine_learning_with_Python --> Python_dashboards Scientific_Python --> Python_for_HPC[Python for HPC] Scientific_Python --> Python_on_GPUs[Python on GPUs] Python_for_HPC --> Python_on_GPUs Python_for_HPC --> Parallel_programming_with_MPI[Parallel programming with MPI] Python_for_programmers --> Python_for_systems_programming[Python for systems programming] click Python_for_beginners \"https://gjbex.github.io/Python-for-beginners/\" \"Python for beginners\" click Python_for_programmers \"https://gjbex.github.io/Python-for-programmers/\" \"Python for programmers\" click Python_software_engineering \"https://gjbex.github.io/Python-software-engineering/\" \"Python software engineering\" click Scientific_Python \"https://gjbex.github.io/Scientific-Python/\" \"Scientific Python\" click Python_for_data_science \"https://gjbex.github.io/Python-for-data-science/\" \"Python for data science\" click Machine_learning_with_Python \"https://gjbex.github.io/Machine-learning-with-Python/\" \"Machine learning with Python\" click Python_dashboards \"https://gjbex.github.io/Python-dashboards/\" \"Python dashboards\" click Python_for_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python for HPC\" click Python_on_GPUs \"https://gjbex.github.io/Python-on-GPUs/\" \"Python on GPUs\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click Python_for_systems_programming \"https://gjbex.github.io/Python-for-systems-programming/\" \"Python for systems programming\"","title":"Python"},{"location":"python/#python-programming","text":"Python is a versatile programming language that is used in many domains. graph TD Python_for_beginners[Python for beginners] --> Python_for_programmers[Python for programmers] Python_for_programmers --> Python_software_engineering[Python software engineering] Python_for_programmers --> Scientific_Python[Scientific Python] Scientific_Python --> Python_for_data_science[Python for data science] Python_for_programmers --> Python_for_data_science Python_for_programmers --> Machine_learning_with_Python[Machine learning with Python] Python_for_data_science --> Machine_learning_with_Python Python_for_data_science --> Python_dashboards[Python dashboards] Machine_learning_with_Python --> Python_dashboards Scientific_Python --> Python_for_HPC[Python for HPC] Scientific_Python --> Python_on_GPUs[Python on GPUs] Python_for_HPC --> Python_on_GPUs Python_for_HPC --> Parallel_programming_with_MPI[Parallel programming with MPI] Python_for_programmers --> Python_for_systems_programming[Python for systems programming] click Python_for_beginners \"https://gjbex.github.io/Python-for-beginners/\" \"Python for beginners\" click Python_for_programmers \"https://gjbex.github.io/Python-for-programmers/\" \"Python for programmers\" click Python_software_engineering \"https://gjbex.github.io/Python-software-engineering/\" \"Python software engineering\" click Scientific_Python \"https://gjbex.github.io/Scientific-Python/\" \"Scientific Python\" click Python_for_data_science \"https://gjbex.github.io/Python-for-data-science/\" \"Python for data science\" click Machine_learning_with_Python \"https://gjbex.github.io/Machine-learning-with-Python/\" \"Machine learning with Python\" click Python_dashboards \"https://gjbex.github.io/Python-dashboards/\" \"Python dashboards\" click Python_for_HPC \"https://gjbex.github.io/Python-for-HPC/\" \"Python for HPC\" click Python_on_GPUs \"https://gjbex.github.io/Python-on-GPUs/\" \"Python on GPUs\" click Parallel_programming_with_MPI \"https://gjbex.github.io/Training-sessions/parallel_programming_with_mpi\" \"Parallel programming with MPI\" click Python_for_systems_programming \"https://gjbex.github.io/Python-for-systems-programming/\" \"Python for systems programming\"","title":"Python programming"},{"location":"scientific_computing/","text":"Scientific computing graph LR Best_practices_for_scientific_computing[Best practices for scientific computing] --> Using_HPC_systems[Using HPC systems] Best_practices_for_scientific_computing --> Version_control_with_git[Version control with git] Best_practices_for_scientific_computing --> Containers_on_HPC[Containers on HPC] Best_practices_for_scientific_computing --> Workflows_for_HPC[Workflows for HPC] Best_practices_for_scientific_computing --> Jupyter_notebooks[Jupyter notebooks] Best_practices_for_scientific_computing --> Data_analysis_and_visualization[Data analysis and visualization] Best_practices_for_scientific_computing --> Best_practices_for_data_science_on_HPC[Best practices for data science on HPC] click Best_practices_for_scientific_computing \"https://gjbex.github.io/Training-sessions/best_practices_for_scientific_computing\" \"Best practices for scientific computing\" click Using_HPC_systems \"https://gjbex.github.io/Training-sessions/using_hpc_systems\" \"Using HPC systems\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git/\" \"Version control with git\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Workflows_for_HPC \"https://gjbex.github.io/Workflows-for-HPC/\" \"Workflows for HPC\" click Jupyter_notebooks \"https://gjbex.github.io/Jupyter-notebooks/\" \"Jupyter notebooks\" click Data_analysis_and_visualization \"https://gjbex.github.io/Training-sessions/data_analysis_and_visualization\" \"Data analysis and visualization\" click Best_practices_for_data_science_on_HPC \"https://gjbex.github.io/Training-sessions/best_practices_for_data_science_on_HPC\" \"Best practices for data science on HPC\" Scientific computing is a broad field that encompasses many different aspects of computing. It is the application of computer algorithms to solve scientific problems. This can range from simple data analysis to complex simulations. However, it also requires a certain mindset and knowledge of best practices to ensure that the results are reliable and reproducible. This includes knowledge of version control , software design, testing, and documentation. For more information on this topic, see \" Best practices for scientific computing \".","title":"Scientific computing"},{"location":"scientific_computing/#scientific-computing","text":"graph LR Best_practices_for_scientific_computing[Best practices for scientific computing] --> Using_HPC_systems[Using HPC systems] Best_practices_for_scientific_computing --> Version_control_with_git[Version control with git] Best_practices_for_scientific_computing --> Containers_on_HPC[Containers on HPC] Best_practices_for_scientific_computing --> Workflows_for_HPC[Workflows for HPC] Best_practices_for_scientific_computing --> Jupyter_notebooks[Jupyter notebooks] Best_practices_for_scientific_computing --> Data_analysis_and_visualization[Data analysis and visualization] Best_practices_for_scientific_computing --> Best_practices_for_data_science_on_HPC[Best practices for data science on HPC] click Best_practices_for_scientific_computing \"https://gjbex.github.io/Training-sessions/best_practices_for_scientific_computing\" \"Best practices for scientific computing\" click Using_HPC_systems \"https://gjbex.github.io/Training-sessions/using_hpc_systems\" \"Using HPC systems\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git/\" \"Version control with git\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Workflows_for_HPC \"https://gjbex.github.io/Workflows-for-HPC/\" \"Workflows for HPC\" click Jupyter_notebooks \"https://gjbex.github.io/Jupyter-notebooks/\" \"Jupyter notebooks\" click Data_analysis_and_visualization \"https://gjbex.github.io/Training-sessions/data_analysis_and_visualization\" \"Data analysis and visualization\" click Best_practices_for_data_science_on_HPC \"https://gjbex.github.io/Training-sessions/best_practices_for_data_science_on_HPC\" \"Best practices for data science on HPC\" Scientific computing is a broad field that encompasses many different aspects of computing. It is the application of computer algorithms to solve scientific problems. This can range from simple data analysis to complex simulations. However, it also requires a certain mindset and knowledge of best practices to ensure that the results are reliable and reproducible. This includes knowledge of version control , software design, testing, and documentation. For more information on this topic, see \" Best practices for scientific computing \".","title":"Scientific computing"},{"location":"scientific_visualization_with_paraview/","text":"Scientific visualization with ParaView (2 hours) ParaView is an open-source, multi-platform data analysis and visualization tools for scientific data. In this training you will learn how to use ParaView to visualize your data. Prerequisites: none","title":"Scientific visualization with ParaView (2 hours)"},{"location":"scientific_visualization_with_paraview/#scientific-visualization-with-paraview-2-hours","text":"ParaView is an open-source, multi-platform data analysis and visualization tools for scientific data. In this training you will learn how to use ParaView to visualize your data. Prerequisites: none","title":"Scientific visualization with ParaView (2 hours)"},{"location":"software_engineering/","text":"Software engineering Good practices in software engineering will contribute considerably to the quality of your scientific software. graph TD Best_practices_for_scientific_computing[Best practices for scientific computing] --> Version_control_with_git[Version control with git] Best_practices_for_scientific_computing --> Containers_on_HPC[Containers on HPC] Best_practices_for_scientific_computing --> Programming[Programming] Programming --> Defensive_programming_and_debugging[Defensive programming and debugging] Defensive_programming_and_debugging --> Code_optimization[Code optimization] Programming --> Code_optimization Programming --> Generative_AI_in_software_engineering_and_data_analysis[Generative AI in software engineering and data analysis] Code_optimization --> Parallel_computing[Parallel computing] Code_optimization --> GPU_computing[GPU computing] click Best_practices_for_scientific_computing \"https://gjbex.github.io/Training-sessions/best_practices_for_scientific_computing\" \"Best practices for scientific computing\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git/\" \"Version control with git\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Programming \"https://gjbex.github.io/Training-sessions/programming\" \"Programming\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_computing \"https://gjbex.github.io/Training-sessions/parallel_computing\" \"Parallel computing\" click GPU_computing \"https://gjbex.github.io/Training-sessions/gpu_computing\" \"GPU computing\" click Generative_AI_in_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI in software engineering and data analysis\" If you are new to software engineering in the context of scientific computing, you may want to start with \" Best practices for scientific computing \". Of course, you coding skills should be up to par. For more information on this topic, see \" Programming \". Version control is an essential part of software engineering. For more information on this topic, see \" Version control with git \". Containers are useful tools in the context of software engineering both to create a complete, stable and portable development environment, but also as a means to distribute your software. Writing robust code that has been well-tested is an essential part of software development. Having tests in place is also essential when trying to optimize your code. For more information on this topic, see \" Defensive programming and debugging \". Effectively optimizing your code implies that you have a thorough understanding of the hardware you are using and how your code interacts with it. For more information on this topic, see \" Code optimization \". Parallel or GPU computing is often required to take full advantage of modern compute nodes. For more information on this topic, see \" Parallel computing \" and \" GPU computing \".","title":"Software engineering"},{"location":"software_engineering/#software-engineering","text":"Good practices in software engineering will contribute considerably to the quality of your scientific software. graph TD Best_practices_for_scientific_computing[Best practices for scientific computing] --> Version_control_with_git[Version control with git] Best_practices_for_scientific_computing --> Containers_on_HPC[Containers on HPC] Best_practices_for_scientific_computing --> Programming[Programming] Programming --> Defensive_programming_and_debugging[Defensive programming and debugging] Defensive_programming_and_debugging --> Code_optimization[Code optimization] Programming --> Code_optimization Programming --> Generative_AI_in_software_engineering_and_data_analysis[Generative AI in software engineering and data analysis] Code_optimization --> Parallel_computing[Parallel computing] Code_optimization --> GPU_computing[GPU computing] click Best_practices_for_scientific_computing \"https://gjbex.github.io/Training-sessions/best_practices_for_scientific_computing\" \"Best practices for scientific computing\" click Version_control_with_git \"https://gjbex.github.io/Version-control-with-git/\" \"Version control with git\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Programming \"https://gjbex.github.io/Training-sessions/programming\" \"Programming\" click Defensive_programming_and_debugging \"https://gjbex.github.io/Defensive_programming_and_debugging/\" \"Defensive programming and debugging\" click Code_optimization \"https://gjbex.github.io/Code-optimization/\" \"Code optimization\" click Parallel_computing \"https://gjbex.github.io/Training-sessions/parallel_computing\" \"Parallel computing\" click GPU_computing \"https://gjbex.github.io/Training-sessions/gpu_computing\" \"GPU computing\" click Generative_AI_in_software_engineering_and_data_analysis \"https://gjbex.github.io/Training-sessions/generative_ai_for_software_engineering_and_data_analysis\" \"Generative AI in software engineering and data analysis\" If you are new to software engineering in the context of scientific computing, you may want to start with \" Best practices for scientific computing \". Of course, you coding skills should be up to par. For more information on this topic, see \" Programming \". Version control is an essential part of software engineering. For more information on this topic, see \" Version control with git \". Containers are useful tools in the context of software engineering both to create a complete, stable and portable development environment, but also as a means to distribute your software. Writing robust code that has been well-tested is an essential part of software development. Having tests in place is also essential when trying to optimize your code. For more information on this topic, see \" Defensive programming and debugging \". Effectively optimizing your code implies that you have a thorough understanding of the hardware you are using and how your code interacts with it. For more information on this topic, see \" Code optimization \". Parallel or GPU computing is often required to take full advantage of modern compute nodes. For more information on this topic, see \" Parallel computing \" and \" GPU computing \".","title":"Software engineering"},{"location":"using_hpc_systems/","text":"Using HPC systems graph LR Linux_intro[Linux introduction] --> HPC_intro[HPC introduction] HPC_intro --> Containers_on_HPC[Containers on HPC] HPC_intro --> Workflows_for_HPC[Workflows for HPC] HPC_intro --> MLOps_on_HPC[MLOps on HPC] click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Workflows_for_HPC \"https://gjbex.github.io/Workflows-for-HPC/\" \"Workflows for HPC\" click MLOps_on_HPC \"https://gjbex.github.io/MLOps-on-HPC/\" \"MLOps on HPC\"","title":"Using HPC systems"},{"location":"using_hpc_systems/#using-hpc-systems","text":"graph LR Linux_intro[Linux introduction] --> HPC_intro[HPC introduction] HPC_intro --> Containers_on_HPC[Containers on HPC] HPC_intro --> Workflows_for_HPC[Workflows for HPC] HPC_intro --> MLOps_on_HPC[MLOps on HPC] click Linux_intro \"https://gjbex.github.io/Training-sessions/linux_intro\" \"Linux introduction\" click HPC_intro \"https://gjbex.github.io/Training-sessions/hpc_intro\" \"HPC introduction\" click Containers_on_HPC \"https://gjbex.github.io/Containers-for-HPC/\" \"Containers on HPC\" click Workflows_for_HPC \"https://gjbex.github.io/Workflows-for-HPC/\" \"Workflows for HPC\" click MLOps_on_HPC \"https://gjbex.github.io/MLOps-on-HPC/\" \"MLOps on HPC\"","title":"Using HPC systems"}]}